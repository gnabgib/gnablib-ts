import { suite } from 'uvu';
import * as assert from 'uvu/assert';
import { hex } from '../../../src/codec';
import { Lea256 } from '../../../src/crypto/sym/Lea';


const tsts = suite('LEA-256');

// prettier-ignore
const tests:[string,string,string][]=[
    //https://en.wikipedia.org/wiki/LEA_(cipher)
    ['0F1E2D3C4B5A69788796A5B4C3D2E1F0F0E1D2C3B4A5968778695A4B3C2D1E0F','303132333435363738393A3B3C3D3E3F','D651AFF647B189C13A8900CA27F9E197'],
    //LEA256(ECB)KAT.txt (subset) | https://github.com/RyuaNerin/go-krypto/blob/master/lea/test_256_test.go
    //zero key, varying plain
    ['0000000000000000000000000000000000000000000000000000000000000000','80000000000000000000000000000000','BA91D622BAF683D7BFCF1785FBE32A44'],
    ['0000000000000000000000000000000000000000000000000000000000000000','C0000000000000000000000000000000','1188E33909A1B2E7126B2BF946407A4F'],
    ['0000000000000000000000000000000000000000000000000000000000000000','E0000000000000000000000000000000','73C499FDA4E73451C3780B055A476944'],
    ['0000000000000000000000000000000000000000000000000000000000000000','F0000000000000000000000000000000','2E87166FC6AA9A5072618F76F1461844'],
    ['0000000000000000000000000000000000000000000000000000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','B1E765F6262FE1FB5615B91A7322EABB'],
    
    //zero plain, varying key
    ['8000000000000000000000000000000000000000000000000000000000000000','00000000000000000000000000000000','4F6156C0C35F9DDFD2A1774814EA76A2'],
    ['C000000000000000000000000000000000000000000000000000000000000000','00000000000000000000000000000000','D84D646949066DC7373981C75F76432F'],
    ['E000000000000000000000000000000000000000000000000000000000000000','00000000000000000000000000000000','B2A01A3C22BC7DA4C6D512F72CC4D667'],
    ['F000000000000000000000000000000000000000000000000000000000000000','00000000000000000000000000000000','65615453112852D192175BB6F90E30CB'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000000','611E921AF6DFECD184C940E604BE93D4'],

    //zero key, variety plain
    ['0000000000000000000000000000000000000000000000000000000000000000','754B4A785D91BB98E5867CBD7CE81ACF','B334F52E0C9F49F205A415277B47B00E'],
    ['0000000000000000000000000000000000000000000000000000000000000000','C0F2BCED9EE960A7BBF2676E13265448','80A267E8955407D52264C83F56C3D4AD'],
    ['0000000000000000000000000000000000000000000000000000000000000000','E1E8D1C9BE76F33E0CBFBE2B9575ECF8','190518F60B7F12684B51C4D698F0D810'],

];
for (const [key,plain,enc] of tests) {
    const c=new Lea256(hex.toBytes(key));
    tsts(`b(${key}).encrypt(${plain})`, () => {
        //Set found equal to plain-source-bytes
        const found=hex.toBytes(plain);
        //Encrypt a block (note the test vectors are all one block)
        c.encryptBlock(found);
        assert.is(hex.fromBytes(found),enc);
    });
    tsts(`b(${key}).decrypt(${enc})`, () => {
        //Set found equal to encoded-source-bytes
        const found=hex.toBytes(enc);
        //Decrypt a block (note the test vectors are all one block)
        c.decryptBlock(found);
        assert.is(hex.fromBytes(found),plain);
    });
}


tsts.run();