import { suite } from 'uvu';
import * as assert from 'uvu/assert';
import { hex } from '../../src/encoding/Hex';
import { Uint64 } from '../../src/primitive/Uint64';

const tsts = suite('UInt64');

// We write in big-endian.. 1234, the 1 is most significant (big) and the 4 is least (little)
// iso8601 is in big endian 2022-02-16, the year is first (big)
// x86/64 is in little-endian, the benefit being reading memory as a byte/word/int/long works the same way
// [01][02][03][04]...> increasing
// as byte=01
// as word=0201
// as int=04030201
// notice they are all 01 on the little end
//Yeah.. confusing

const lShiftSet = [
	['0000000000000000', 0, '0000000000000000'],
	['0000000000000000', 1, '0000000000000000'],
	['0000000000000000', 13, '0000000000000000'],
	['0000000000000000', 32, '0000000000000000'],
	['0000000000000000', 64, '0000000000000000'],

	['FFFFFFFFFFFFFFFF', 0, 'FFFFFFFFFFFFFFFF'],
	['FFFFFFFFFFFFFFFF', 1, 'FFFFFFFFFFFFFFFE'],
	['FFFFFFFFFFFFFFFF', 13, 'FFFFFFFFFFFFE000'],
	['FFFFFFFFFFFFFFFF', 32, 'FFFFFFFF00000000'],
	['FFFFFFFFFFFFFFFF', 64, '0000000000000000'],

	['FEDCBA9876543210', 0, 'FEDCBA9876543210'],
	['FEDCBA9876543210', 1, 'FDB97530ECA86420'],
	['FEDCBA9876543210', 4, 'EDCBA98765432100'],
	['FEDCBA9876543210', 8, 'DCBA987654321000'],
	['FEDCBA9876543210', 16, 'BA98765432100000'],
	['FEDCBA9876543210', 24, '9876543210000000'],
	['FEDCBA9876543210', 28, '8765432100000000'],
	['FEDCBA9876543210', 31, '3B2A190800000000'],
	['FEDCBA9876543210', 32, '7654321000000000'],
	['FEDCBA9876543210', 33, 'ECA8642000000000'],
	['FEDCBA9876543210', 36, '6543210000000000'],
	['FEDCBA9876543210', 48, '3210000000000000'],
	['FEDCBA9876543210', 63, '0000000000000000'],
	['FEDCBA9876543210', 64, '0000000000000000'],

	['0123456789ABCDEF', 0, '0123456789ABCDEF'],
	['0123456789ABCDEF', 1, '02468ACF13579BDE'],
	['0123456789ABCDEF', 4, '123456789ABCDEF0'],
	['0123456789ABCDEF', 8, '23456789ABCDEF00'],
	['0123456789ABCDEF', 16, '456789ABCDEF0000'],
	['0123456789ABCDEF', 24, '6789ABCDEF000000'],
	['0123456789ABCDEF', 28, '789ABCDEF0000000'],
	['0123456789ABCDEF', 31, 'C4D5E6F780000000'],
	['0123456789ABCDEF', 32, '89ABCDEF00000000'],
	['0123456789ABCDEF', 33, '13579BDE00000000'],
	['0123456789ABCDEF', 48, 'CDEF000000000000'],
	['0123456789ABCDEF', 64, '0000000000000000'],

	['8765432112345678', 8, '6543211234567800'],
	['8765432112345678', 44, '4567800000000000'],
];

for (const test of lShiftSet) {
	tsts(test[0] + '<<' + test[1], () => {
		const b = hex.toBytes(test[0] as string);
		const start = Uint64.fromBytes(b);
		const res = start.lShift(test[1] as number);
		//console.log('start',start,'res',res);
		assert.is(hex.fromBytes(res.toBytes()), test[2]);
	});
}

const lRotSet = [
	['0000000000000000', 0, '0000000000000000'],
	['0000000000000000', 1, '0000000000000000'],
	['0000000000000000', 13, '0000000000000000'],
	['0000000000000000', 32, '0000000000000000'],
	['0000000000000000', 64, '0000000000000000'],

	['FEDCBA9876543210', 0, 'FEDCBA9876543210'],
	['FEDCBA9876543210', 1, 'FDB97530ECA86421'],
	['FEDCBA9876543210', 4, 'EDCBA9876543210F'],
	['FEDCBA9876543210', 8, 'DCBA9876543210FE'],
	['FEDCBA9876543210', 12, 'CBA9876543210FED'],
	['FEDCBA9876543210', 16, 'BA9876543210FEDC'],
	['FEDCBA9876543210', 20, 'A9876543210FEDCB'],
	['FEDCBA9876543210', 24, '9876543210FEDCBA'],
	['FEDCBA9876543210', 28, '876543210FEDCBA9'],
	['FEDCBA9876543210', 31, '3B2A19087F6E5D4C'],
	['FEDCBA9876543210', 32, '76543210FEDCBA98'],
	['FEDCBA9876543210', 33, 'ECA86421FDB97530'],
	['FEDCBA9876543210', 36, '6543210FEDCBA987'],
	['FEDCBA9876543210', 40, '543210FEDCBA9876'],
	['FEDCBA9876543210', 44, '43210FEDCBA98765'],
	['FEDCBA9876543210', 48, '3210FEDCBA987654'],
	['FEDCBA9876543210', 52, '210FEDCBA9876543'],
	['FEDCBA9876543210', 56, '10FEDCBA98765432'],
	['FEDCBA9876543210', 60, '0FEDCBA987654321'],
	['FEDCBA9876543210', 63, '7F6E5D4C3B2A1908'],
	['FEDCBA9876543210', 64, 'FEDCBA9876543210'],

	['0123456789ABCDEF', 0, '0123456789ABCDEF'],
	['0123456789ABCDEF', 1, '02468ACF13579BDE'],
	['0123456789ABCDEF', 4, '123456789ABCDEF0'],
	['0123456789ABCDEF', 8, '23456789ABCDEF01'],
	['0123456789ABCDEF', 12, '3456789ABCDEF012'],
	['0123456789ABCDEF', 16, '456789ABCDEF0123'],
	['0123456789ABCDEF', 20, '56789ABCDEF01234'],
	['0123456789ABCDEF', 24, '6789ABCDEF012345'],
	['0123456789ABCDEF', 28, '789ABCDEF0123456'],
	['0123456789ABCDEF', 31, 'C4D5E6F78091A2B3'],
	['0123456789ABCDEF', 32, '89ABCDEF01234567'],
	['0123456789ABCDEF', 33, '13579BDE02468ACF'],
	['0123456789ABCDEF', 36, '9ABCDEF012345678'],
	['0123456789ABCDEF', 40, 'ABCDEF0123456789'],
	['0123456789ABCDEF', 44, 'BCDEF0123456789A'],
	['0123456789ABCDEF', 48, 'CDEF0123456789AB'],
	['0123456789ABCDEF', 52, 'DEF0123456789ABC'],
	['0123456789ABCDEF', 56, 'EF0123456789ABCD'],
	['0123456789ABCDEF', 60, 'F0123456789ABCDE'],
	['0123456789ABCDEF', 63, '8091A2B3C4D5E6F7'],
	['0123456789ABCDEF', 64, '0123456789ABCDEF'],
];

for (const test of lRotSet) {
	tsts(test[0] + '<<(rot)' + test[1], () => {
		const b = hex.toBytes(test[0] as string);
		const start = Uint64.fromBytes(b);
		const res = start.lRot(test[1] as number);
		assert.is(hex.fromBytes(res.toBytes()), test[2]);
	});
}

const rShiftSet = [
	['0000000000000000', 0, '0000000000000000'],
	['0000000000000000', 1, '0000000000000000'],
	['0000000000000000', 13, '0000000000000000'],
	['0000000000000000', 32, '0000000000000000'],
	['0000000000000000', 64, '0000000000000000'],

	['FFFFFFFFFFFFFFFF', 0, 'FFFFFFFFFFFFFFFF'],
	['FFFFFFFFFFFFFFFF', 1, '7FFFFFFFFFFFFFFF'],
	['FFFFFFFFFFFFFFFF', 13, '0007FFFFFFFFFFFF'],
	['FFFFFFFFFFFFFFFF', 32, '00000000FFFFFFFF'],
	['FFFFFFFFFFFFFFFF', 64, '0000000000000000'],

	['FEDCBA9876543210', 0, 'FEDCBA9876543210'],
	['FEDCBA9876543210', 1, '7F6E5D4C3B2A1908'],
	['FEDCBA9876543210', 4, '0FEDCBA987654321'],
	['FEDCBA9876543210', 8, '00FEDCBA98765432'],
	['FEDCBA9876543210', 16, '0000FEDCBA987654'],
	['FEDCBA9876543210', 24, '000000FEDCBA9876'],
	['FEDCBA9876543210', 28, '0000000FEDCBA987'],
	['FEDCBA9876543210', 31, '00000001FDB97530'],
	['FEDCBA9876543210', 32, '00000000FEDCBA98'],
	['FEDCBA9876543210', 33, '000000007F6E5D4C'],
	['FEDCBA9876543210', 36, '000000000FEDCBA9'],
	['FEDCBA9876543210', 48, '000000000000FEDC'],
	['FEDCBA9876543210', 63, '0000000000000001'],
	['FEDCBA9876543210', 64, '0000000000000000'],

	['0123456789ABCDEF', 0, '0123456789ABCDEF'],
	['0123456789ABCDEF', 1, '0091A2B3C4D5E6F7'],
	['0123456789ABCDEF', 4, '00123456789ABCDE'],
	['0123456789ABCDEF', 8, '000123456789ABCD'],
	['0123456789ABCDEF', 16, '00000123456789AB'],
	['0123456789ABCDEF', 24, '0000000123456789'],
	['0123456789ABCDEF', 28, '0000000012345678'],
	['0123456789ABCDEF', 31, '0000000002468ACF'],
	['0123456789ABCDEF', 32, '0000000001234567'],
	['0123456789ABCDEF', 33, '000000000091A2B3'],
	['0123456789ABCDEF', 48, '0000000000000123'],
	['0123456789ABCDEF', 63, '0000000000000000'],
	['0123456789ABCDEF', 64, '0000000000000000'],
];

for (const test of rShiftSet) {
	//Note JS has >> (sign aware) and >>> (zero fill) right shift,
	// but since this is an unsigned int, they have the same meaning
	tsts(test[0] + '>>>' + test[1], () => {
		const b = hex.toBytes(test[0] as string);
		const start = Uint64.fromBytes(b);
		const res = start.rShift(test[1] as number);
		//console.log('start',start,'res',res);
		assert.is(hex.fromBytes(res.toBytes()), test[2]);
	});
}

const rRotSet = [
	['0000000000000000', 0, '0000000000000000'],
	['0000000000000000', 1, '0000000000000000'],
	['0000000000000000', 13, '0000000000000000'],
	['0000000000000000', 32, '0000000000000000'],
	['0000000000000000', 64, '0000000000000000'],

	['FEDCBA9876543210', 0, 'FEDCBA9876543210'],
	['FEDCBA9876543210', 1, '7F6E5D4C3B2A1908'],
	['FEDCBA9876543210', 4, '0FEDCBA987654321'],
	['FEDCBA9876543210', 8, '10FEDCBA98765432'],
	['FEDCBA9876543210', 12, '210FEDCBA9876543'],
	['FEDCBA9876543210', 16, '3210FEDCBA987654'],
	['FEDCBA9876543210', 20, '43210FEDCBA98765'],
	['FEDCBA9876543210', 24, '543210FEDCBA9876'],
	['FEDCBA9876543210', 28, '6543210FEDCBA987'],
	['FEDCBA9876543210', 31, 'ECA86421FDB97530'],
	['FEDCBA9876543210', 32, '76543210FEDCBA98'],
	['FEDCBA9876543210', 33, '3B2A19087F6E5D4C'],
	['FEDCBA9876543210', 36, '876543210FEDCBA9'],
	['FEDCBA9876543210', 40, '9876543210FEDCBA'],
	['FEDCBA9876543210', 44, 'A9876543210FEDCB'],
	['FEDCBA9876543210', 48, 'BA9876543210FEDC'],
	['FEDCBA9876543210', 52, 'CBA9876543210FED'],
	['FEDCBA9876543210', 56, 'DCBA9876543210FE'],
	['FEDCBA9876543210', 60, 'EDCBA9876543210F'],
	['FEDCBA9876543210', 63, 'FDB97530ECA86421'],
	['FEDCBA9876543210', 64, 'FEDCBA9876543210'],

	['0123456789ABCDEF', 0, '0123456789ABCDEF'],
	['0123456789ABCDEF', 1, '8091A2B3C4D5E6F7'],
	['0123456789ABCDEF', 4, 'F0123456789ABCDE'],
	['0123456789ABCDEF', 8, 'EF0123456789ABCD'],
	['0123456789ABCDEF', 12, 'DEF0123456789ABC'],
	['0123456789ABCDEF', 16, 'CDEF0123456789AB'],
	['0123456789ABCDEF', 20, 'BCDEF0123456789A'],
	['0123456789ABCDEF', 24, 'ABCDEF0123456789'],
	['0123456789ABCDEF', 28, '9ABCDEF012345678'],
	['0123456789ABCDEF', 31, '13579BDE02468ACF'],
	['0123456789ABCDEF', 32, '89ABCDEF01234567'],
	['0123456789ABCDEF', 33, 'C4D5E6F78091A2B3'],
	['0123456789ABCDEF', 36, '789ABCDEF0123456'],
	['0123456789ABCDEF', 40, '6789ABCDEF012345'],
	['0123456789ABCDEF', 44, '56789ABCDEF01234'],
	['0123456789ABCDEF', 48, '456789ABCDEF0123'],
	['0123456789ABCDEF', 52, '3456789ABCDEF012'],
	['0123456789ABCDEF', 56, '23456789ABCDEF01'],
	['0123456789ABCDEF', 60, '123456789ABCDEF0'],
	['0123456789ABCDEF', 63, '02468ACF13579BDE'],
	['0123456789ABCDEF', 64, '0123456789ABCDEF'],
];

for (const test of rRotSet) {
	tsts(test[0] + '>>>(rot)' + test[1], () => {
		const b = hex.toBytes(test[0] as string);
		const start = Uint64.fromBytes(b);
		const res = start.rRot(test[1] as number);
		assert.is(hex.fromBytes(res.toBytes()), test[2]);
	});
}

// prettier-ignore
const xorSet=[
    // A^0=A: Anything xor zero is anything
    ['0000000000000000','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['0000000000000000','0123456789ABCDEF','0123456789ABCDEF'],
    ['0000000000000000','FEDCBA9876543210','FEDCBA9876543210'],
    ['0000000000000000','0000000000000000','0000000000000000'],
    // A^1=~A:  Anything XOR 1 is its compliment
    ['FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF','0000000000000000'],
    ['FFFFFFFFFFFFFFFF','0123456789ABCDEF','FEDCBA9876543210'],
    ['FFFFFFFFFFFFFFFF','FEDCBA9876543210','0123456789ABCDEF'],
    // A^~A=1 Anything xor its compliment is 1
    ['00000000FFFFFFFF','FFFFFFFF00000000','FFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A53C','3C5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFF'],
    ['C35A5A5A5A5A5A3C','3CA5A5A5A5A5A5C3','FFFFFFFFFFFFFFFF'],
    ['FEDCBA9876543210','0123456789ABCDEF','FFFFFFFFFFFFFFFF'],
    // A^A=A Anything xor itself is 0
    ['00000000FFFFFFFF','00000000FFFFFFFF','0000000000000000'],
    ['C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C','0000000000000000'],
    ['C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C','0000000000000000'],
    ['FEDCBA9876543210','FEDCBA9876543210','0000000000000000'],
    // Other cases
    ['FEDCBA9876543210','0000000FFFFFFFFF','FEDCBA9789ABCDEF'],
    ['C3A5A5A5A5A5A53C','0000000FFFFFFFFF','C3A5A5AA5A5A5AC3'],
    ['FEDCBA9876543210','FFFFFFFFF0000000','0123456786543210'],
    ['C3A5A5A5A5A5A53C','FFFFFFFFF0000000','3C5A5A5A55A5A53C'],
    ['0000000000000001','0000000000000002','0000000000000003'],
    ['0000000000000001','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFE'],
];

for (const test of xorSet) {
	tsts(test[0] + '^' + test[1], () => {
		const aBytes = hex.toBytes(test[0] as string);
		const aUint = Uint64.fromBytes(aBytes);
		const bBytes = hex.toBytes(test[1] as string);
		const bUint = Uint64.fromBytes(bBytes);
		const res = aUint.xor(bUint);
		assert.is(hex.fromBytes(res.toBytes()), test[2]);
	});
}

// prettier-ignore
const orSet=[
    // A|0=A: Anything or zero is anything
    ['0000000000000000','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['0000000000000000','0123456789ABCDEF','0123456789ABCDEF'],
    ['0000000000000000','FEDCBA9876543210','FEDCBA9876543210'],
    ['0000000000000000','0000000000000000','0000000000000000'],
    // A|1=1:  Anything or 1 is 1
    ['FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFF','0123456789ABCDEF','FFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFF','FEDCBA9876543210','FFFFFFFFFFFFFFFF'],
    // A|~A=1: Anything or its compliment is 1
    ['00000000FFFFFFFF','FFFFFFFF00000000','FFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A53C','3C5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFF'],
    ['C35A5A5A5A5A5A3C','3CA5A5A5A5A5A5C3','FFFFFFFFFFFFFFFF'],
    ['FEDCBA9876543210','0123456789ABCDEF','FFFFFFFFFFFFFFFF'],
    // A|A=A: Anything or itself is itself
    ['00000000FFFFFFFF','00000000FFFFFFFF','00000000FFFFFFFF'],
    ['C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C'],
    ['C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C'],
    ['FEDCBA9876543210','FEDCBA9876543210','FEDCBA9876543210'],
    // Any bits set override the other value (form of masking)
    ['FEDCBA9876543210','0000000FFFFFFFFF','FEDCBA9FFFFFFFFF'],
    ['C3A5A5A5A5A5A53C','0000000FFFFFFFFF','C3A5A5AFFFFFFFFF'],
    ['FEDCBA9876543210','FFFFFFFFF0000000','FFFFFFFFF6543210'],
    ['C3A5A5A5A5A5A53C','FFFFFFFFF0000000','FFFFFFFFF5A5A53C'],
    ['0000000000000001','0000000000000002','0000000000000003'],
    ['0000000000000001','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
];

for (const test of orSet) {
	tsts(test[0] + '|' + test[1], () => {
		const aBytes = hex.toBytes(test[0] as string);
		const aUint = Uint64.fromBytes(aBytes);
		const bBytes = hex.toBytes(test[1] as string);
		const bUint = Uint64.fromBytes(bBytes);
		const res = aUint.or(bUint);
		assert.is(hex.fromBytes(res.toBytes()), test[2]);
	});
}

// prettier-ignore
const andSet=[
    // A&0=0: Zero and anything is zero
    ['0000000000000000','FFFFFFFFFFFFFFFF','0000000000000000'],
    ['0000000000000000','0123456789ABCDEF','0000000000000000'],
    ['0000000000000000','FEDCBA9876543210','0000000000000000'],
    ['0000000000000000','0000000000000000','0000000000000000'],
    // A&1=A:  All set and anything is anything
    ['FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFF','0123456789ABCDEF','0123456789ABCDEF'],
    ['FFFFFFFFFFFFFFFF','FEDCBA9876543210','FEDCBA9876543210'],
    // A&~A=0: Anything and its compliment is 0
    ['00000000FFFFFFFF','FFFFFFFF00000000','0000000000000000'],
    ['C3A5A5A5A5A5A53C','3C5A5A5A5A5A5AC3','0000000000000000'],
    ['C35A5A5A5A5A5A3C','3CA5A5A5A5A5A5C3','0000000000000000'],
    ['FEDCBA9876543210','0123456789ABCDEF','0000000000000000'],
    // A&A=A: Anything and itself is itself
    ['00000000FFFFFFFF','00000000FFFFFFFF','00000000FFFFFFFF'],
    ['C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C'],
    ['C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C'],
    ['FEDCBA9876543210','FEDCBA9876543210','FEDCBA9876543210'],
    // Only bits set to true in both survive (form of masking)
    ['FEDCBA9876543210','0000000FFFFFFFFF','0000000876543210'],
    ['C3A5A5A5A5A5A53C','0000000FFFFFFFFF','00000005A5A5A53C'],
    ['FEDCBA9876543210','FFFFFFFFF0000000','FEDCBA9870000000'],
    ['C3A5A5A5A5A5A53C','FFFFFFFFF0000000','C3A5A5A5A0000000'],
    ['0000000000000001','0000000000000002','0000000000000000'],
    ['0000000000000001','FFFFFFFFFFFFFFFF','0000000000000001'],
];

for (const test of andSet) {
	tsts(test[0] + '&' + test[1], () => {
		const aBytes = hex.toBytes(test[0] as string);
		const aUint = Uint64.fromBytes(aBytes);
		const bBytes = hex.toBytes(test[1] as string);
		const bUint = Uint64.fromBytes(bBytes);
		const res = aUint.and(bUint);
		assert.is(hex.fromBytes(res.toBytes()), test[2]);
	});
}

const notSet = [
	['0000000000000000', 'FFFFFFFFFFFFFFFF'],
	['00000000FFFFFFFF', 'FFFFFFFF00000000'],
	['FFFFFFFF00000000', '00000000FFFFFFFF'],
	['FFFFFFFFFFFFFFFF', '0000000000000000'],
	['C3A5A5A5A5A5A53C', '3C5A5A5A5A5A5AC3'], //A=1010, 5=0101, C=1100, 3=0011
	['C35A5A5A5A5A5A3C', '3CA5A5A5A5A5A5C3'],
	['FEDCBA9876543210', '0123456789ABCDEF'],
	['0123456789ABCDEF', 'FEDCBA9876543210'],
];

for (const test of notSet) {
	tsts('~' + test[0], () => {
		const b = hex.toBytes(test[0] as string);
		const start = Uint64.fromBytes(b);
		const res = start.not();
		assert.is(hex.fromBytes(res.toBytes()), test[1]);
	});
}

// prettier-ignore
const addSet=[
    // A+0=A: Anything plus zero is anything (like or)
    ['0000000000000000','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['0000000000000000','0123456789ABCDEF','0123456789ABCDEF'],
    ['0000000000000000','FEDCBA9876543210','FEDCBA9876543210'],
    ['0000000000000000','0000000000000000','0000000000000000'],
    // A+1=A:  Anything plus 1 overflows
    ['FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFE'],//Overflow
    ['FFFFFFFFFFFFFFFF','0123456789ABCDEF','0123456789ABCDEE'],//Overflow
    ['FFFFFFFFFFFFFFFF','FEDCBA9876543210','FEDCBA987654320F'],//Overflow
    ['FFFFFFFFFFFFFFFF','0000000000000000','FFFFFFFFFFFFFFFF'],
    // A+~A .. is 1 (like or)
    ['00000000FFFFFFFF','FFFFFFFF00000000','FFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A53C','3C5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFF'],
    ['C35A5A5A5A5A5A3C','3CA5A5A5A5A5A5C3','FFFFFFFFFFFFFFFF'],
    ['FEDCBA9876543210','0123456789ABCDEF','FFFFFFFFFFFFFFFF'],
    // A+A=2A
    ['00000000FFFFFFFF','00000000FFFFFFFF','00000001FFFFFFFE'],
    ['C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C','874B4B4B4B4B4A78'],//Overflow
    ['C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C','86B4B4B4B4B4B478'],//Overflow
    ['FEDCBA9876543210','FEDCBA9876543210','FDB97530ECA86420'],//Overflow
    // Others
    ['FEDCBA9876543210','0000000FFFFFFFFF','FEDCBAA87654320F'],
    ['C3A5A5A5A5A5A53C','0000000FFFFFFFFF','C3A5A5B5A5A5A53B'],
    ['FEDCBA9876543210','FFFFFFFFF0000000','FEDCBA9866543210'],//Overflow
    ['C3A5A5A5A5A5A53C','FFFFFFFFF0000000','C3A5A5A595A5A53C'],//Overflow
    ['0000000000000001','0000000000000002','0000000000000003'],
    ['0000000000000001','FFFFFFFFFFFFFFFF','0000000000000000'],//Overflow
];

for (const test of addSet) {
	tsts(test[0] + '+' + test[1], () => {
		const aBytes = hex.toBytes(test[0] as string);
		const aUint = Uint64.fromBytes(aBytes);
		const bBytes = hex.toBytes(test[1] as string);
		const bUint = Uint64.fromBytes(bBytes);
		const res = aUint.add(bUint);
		assert.is(hex.fromBytes(res.toBytes()), test[2]);
	});
}

// prettier-ignore
const mulSet=[
	['0000000000000001','0000000000000002','0000000000000002'],
	['000000000000FFFF','000000000000FFFF','00000000FFFE0001'],
	['00000000000FFFFF','00000000000FFFFF','000000FFFFE00001'],
	['0000000000FFFFFF','0000000000FFFFFF','0000FFFFFE000001'],
	['000000000FFFFFFF','000000000FFFFFFF','00FFFFFFE0000001'],
	['00000000FFFFFFFF','00000000FFFFFFFF','FFFFFFFE00000001'],
	['0000000FFFFFFFFF','0000000FFFFFFFFF','FFFFFFE000000001'],
	['000000FFFFFFFFFF','000000FFFFFFFFFF','FFFFFE0000000001'],
	['00000FFFFFFFFFFF','00000FFFFFFFFFFF','FFFFE00000000001'],
	['0000FFFFFFFFFFFF','0000FFFFFFFFFFFF','FFFE000000000001'],
	['000FFFFFFFFFFFFF','000FFFFFFFFFFFFF','FFE0000000000001'],
	['00FFFFFFFFFFFFFF','00FFFFFFFFFFFFFF','FE00000000000001'],
	['0FFFFFFFFFFFFFFF','0FFFFFFFFFFFFFFF','E000000000000001'],
	['FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF','0000000000000001'],
	['000000000000FFFF','0000000000000003','000000000002FFFD'],
	['00000000000FFFFF','0000000000000035','00000000034FFFCB'],
	['0000000000FFFFFF','0000000000000357','0000000356FFFCA9'],
	['000000000FFFFFFF','000000000000357B','00000357AFFFCA85'],
	['00000000FFFFFFFF','00000000000357BD','000357BCFFFCA843'],
	['0000000FFFFFFFFF','0000000000357BDB','0357BDAFFFCA8425'],
	['000000FFFFFFFFFF','000000000357BDB7','57BDB6FFFCA84249'],
	['00000FFFFFFFFFFF','00000000357BDB75','BDB74FFFCA84248B'],
	['0000FFFFFFFFFFFF','0000000357BDB753','B752FFFCA84248AD'],
	['000FFFFFFFFFFFFF','000000357BDB7535','534FFFCA84248ACB'],
	['00FFFFFFFFFFFFFF','00000357BDB75357','56FFFCA84248ACA9'],
	['0FFFFFFFFFFFFFFF','0000357BDB75357B','AFFFCA84248ACA85'],
	['FFFFFFFFFFFFFFFF','000357BDB75357BD','FFFCA84248ACA843'],
	['0000000000000001','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
	['00000000EE6B2800','000000000000000D','0000000C1B710800'],//4B*13 =52B
	['000000003B9ACA00','000000003B9ACA00','0DE0B6B3A7640000'],//1B*1B=1x10^18
	['0000000ABCDEF123','000000000BEBA7E9','7FFFFFFF32584DDB'],
	['7FFFFFFFFFFFFFFF','0000000000000010','FFFFFFFFFFFFFFF0'],//Prove it is unsigned
	['1111111111111111','000000000000000F','FFFFFFFFFFFFFFFF'],
	['1111111111111111','00000000000000EE','DDDDDDDDDDDDDDCE'],
	['1111111111111111','0000000000000DDD','99999999999998AD'],
	['1111111111111111','000000000000CCCC','333333333333258C'],
	['1111111111111111','00000000000BBBBB','AAAAAAAAAAA9E26B'],
	['1111111111111111','0000000000AAAAAA','FFFFFFFFFFF49F4A'],
	['1111111111111111','0000000009999999','33333333328F5C29'],
	['1111111111111111','0000000088888888','444444443B2A1908'],
	['1111111111111111','0000000777777777','33333332B3C4D5E7'],
	['1111111111111111','0000006666666666','FFFFFFF92C5F92C6'],
	['1111111111111111','0000055555555555','AAAAAA4FA4FA4FA5'],
	['1111111111111111','0000444444444444','33332EA61D950C84'],
	['1111111111111111','0003333333333333','999962FC962FC963'],
	['1111111111111111','0022222222222222','DDDB97530ECA8642'],
	['1111111111111111','0111111111111111','FFEDCBA987654321'],
];

for (const test of mulSet) {
	tsts(test[0] + '*' + test[1], () => {
		const aBytes = hex.toBytes(test[0] as string);
		const aUint = Uint64.fromBytes(aBytes);
		const bBytes = hex.toBytes(test[1] as string);
		const bUint = Uint64.fromBytes(bBytes);
		const res = aUint.mul(bUint);
		assert.is(hex.fromBytes(res.toBytes()), test[2]);
	});
}

const max = Uint64.max;
console.log(max.toString());
//console.log(Uint64.minSigned.toString());

// const lShiftOut = [
// 	['0000000000000000', 0, '00000000000000000000000000000000'],
// 	['0000000000000000', 1, '00000000000000000000000000000000'],
// 	['0000000000000000', 13, '00000000000000000000000000000000'],
// 	['0000000000000000', 32, '00000000000000000000000000000000'],
// 	['0000000000000000', 64, '00000000000000000000000000000000'],

// 	['FEDCBA9876543210', 0, '0000000000000000' + 'FEDCBA9876543210'],
// 	['FEDCBA9876543210', 1, '0000000000000001' + 'FDB97530ECA86420'],
// 	['FEDCBA9876543210', 4, '000000000000000F' + 'EDCBA98765432100'],
// 	['FEDCBA9876543210', 8, '00000000000000FE' + 'DCBA987654321000'],
// 	['FEDCBA9876543210', 12, '0000000000000FED' + 'CBA9876543210000'],
// 	['FEDCBA9876543210', 16, '000000000000FEDC' + 'BA98765432100000'],
// 	['FEDCBA9876543210', 20, '00000000000FEDCB' + 'A987654321000000'],
// 	['FEDCBA9876543210', 24, '0000000000FEDCBA' + '9876543210000000'],
// 	['FEDCBA9876543210', 28, '000000000FEDCBA9' + '8765432100000000'],
// 	['FEDCBA9876543210', 31, '000000007F6E5D4C' + '3B2A190800000000'],
// 	['FEDCBA9876543210', 32, '00000000FEDCBA98' + '7654321000000000'],
// 	['FEDCBA9876543210', 33, '00000001FDB97530' + 'ECA8642000000000'],
// 	['FEDCBA9876543210', 36, '0000000FEDCBA987' + '6543210000000000'],
// 	['FEDCBA9876543210', 40, '000000FEDCBA9876' + '5432100000000000'],
// 	['FEDCBA9876543210', 44, '00000FEDCBA98765' + '4321000000000000'],
// 	['FEDCBA9876543210', 48, '0000FEDCBA987654' + '3210000000000000'],
// 	['FEDCBA9876543210', 52, '000FEDCBA9876543' + '2100000000000000'],
// 	['FEDCBA9876543210', 56, '00FEDCBA98765432' + '1000000000000000'],
// 	['FEDCBA9876543210', 60, '0FEDCBA987654321' + '0000000000000000'],
// 	['FEDCBA9876543210', 63, '7F6E5D4C3B2A1908' + '0000000000000000'],
// 	['FEDCBA9876543210', 64, 'FEDCBA9876543210' + '0000000000000000'],

// 	['0123456789ABCDEF', 0, '0000000000000000' + '0123456789ABCDEF'],
// 	['0123456789ABCDEF', 1, '0000000000000000' + '02468ACF13579BDE'],
// 	['0123456789ABCDEF', 4, '0000000000000000' + '123456789ABCDEF0'],
// 	['0123456789ABCDEF', 8, '0000000000000001' + '23456789ABCDEF00'],
// 	['0123456789ABCDEF', 12, '0000000000000012' + '3456789ABCDEF000'],
// 	['0123456789ABCDEF', 16, '0000000000000123' + '456789ABCDEF0000'],
// 	['0123456789ABCDEF', 20, '0000000000001234' + '56789ABCDEF00000'],
// 	['0123456789ABCDEF', 24, '0000000000012345' + '6789ABCDEF000000'],
// 	['0123456789ABCDEF', 28, '0000000000123456' + '789ABCDEF0000000'],
// 	['0123456789ABCDEF', 31, '000000000091A2B3' + 'C4D5E6F780000000'],
// 	['0123456789ABCDEF', 32, '0000000001234567' + '89ABCDEF00000000'],
// 	['0123456789ABCDEF', 33, '0000000002468ACF' + '13579BDE00000000'],
// 	['0123456789ABCDEF', 36, '0000000012345678' + '9ABCDEF000000000'],
// 	['0123456789ABCDEF', 40, '0000000123456789' + 'ABCDEF0000000000'],
// 	['0123456789ABCDEF', 44, '000000123456789A' + 'BCDEF00000000000'],
// 	['0123456789ABCDEF', 48, '00000123456789AB' + 'CDEF000000000000'],
// 	['0123456789ABCDEF', 52, '0000123456789ABC' + 'DEF0000000000000'],
// 	['0123456789ABCDEF', 56, '000123456789ABCD' + 'EF00000000000000'],
// 	['0123456789ABCDEF', 60, '00123456789ABCDE' + 'F000000000000000'],
// 	['0123456789ABCDEF', 63, '0091A2B3C4D5E6F7' + '8000000000000000'],
// 	['0123456789ABCDEF', 64, '0123456789ABCDEF' + '0000000000000000'],

// 	['8765432112345678', 0, '0000000000000000' + '8765432112345678'],
// 	['8765432112345678', 1, '0000000000000001' + '0ECA86422468ACF0'],
// 	['8765432112345678', 4, '0000000000000008' + '7654321123456780'],
// 	['8765432112345678', 8, '0000000000000087' + '6543211234567800'],
// 	['8765432112345678', 12, '0000000000000876' + '5432112345678000'],
// 	['8765432112345678', 16, '0000000000008765' + '4321123456780000'],
// 	['8765432112345678', 20, '0000000000087654' + '3211234567800000'],
// 	['8765432112345678', 24, '0000000000876543' + '2112345678000000'],
// 	['8765432112345678', 28, '0000000008765432' + '1123456780000000'],
// 	['8765432112345678', 31, '0000000043B2A190' + '891A2B3C00000000'],
// 	['8765432112345678', 32, '0000000087654321' + '1234567800000000'],
// 	['8765432112345678', 33, '000000010ECA8642' + '2468ACF000000000'],
// 	['8765432112345678', 36, '0000000876543211' + '2345678000000000'],
// 	['8765432112345678', 40, '0000008765432112' + '3456780000000000'],
// 	['8765432112345678', 44, '0000087654321123' + '4567800000000000'],
// 	['8765432112345678', 48, '0000876543211234' + '5678000000000000'],
// 	['8765432112345678', 52, '0008765432112345' + '6780000000000000'],
// 	['8765432112345678', 56, '0087654321123456' + '7800000000000000'],
// 	['8765432112345678', 60, '0876543211234567' + '8000000000000000'],
// 	['8765432112345678', 63, '43B2A190891A2B3C' + '0000000000000000'],
// 	['8765432112345678', 64, '8765432112345678' + '0000000000000000']
// ];

// for(const test of lShiftOut) {
// 	tsts(test[0] + '<<(out)' + test[1], () => {
// 		const b = hex.toBytes(test[0] as string);
// 		const start = bigEndian.u64FromBytes(b);
// 		const res = start.lShiftOut(test[1] as number);

//         const sol=hex.fromBytes(bigEndian.u64ToBytes(new Uint64(res[1],res[0])))+
//             hex.fromBytes(bigEndian.u64ToBytes(new Uint64(res[3],res[2])));

// 		assert.is(sol, test[2]);
// 	});

// }

tsts.run();
