import { suite } from 'uvu';
import * as assert from 'uvu/assert';
import { hex } from '../../src/encoding/Hex';
import { UInt } from '../../src/primitive/UInt';

const tsts = suite('UInt');

// prettier-ignore
const xorTest=[
    // A^0=A: Anything xor zero is anything
    ['0000000000000000','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['0000000000000000','0123456789ABCDEF','0123456789ABCDEF'],
    ['0000000000000000','FEDCBA9876543210','FEDCBA9876543210'],
    ['0000000000000000','0000000000000000','0000000000000000'],
    // A^1=~A:  Anything XOR 1 is its compliment
    ['FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF','0000000000000000'],
    ['FFFFFFFFFFFFFFFF','0123456789ABCDEF','FEDCBA9876543210'],
    ['FFFFFFFFFFFFFFFF','FEDCBA9876543210','0123456789ABCDEF'],
    // A^~A=1 Anything xor its compliment is 1
    ['00000000FFFFFFFF','FFFFFFFF00000000','FFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A53C','3C5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFF'],
    ['C35A5A5A5A5A5A3C','3CA5A5A5A5A5A5C3','FFFFFFFFFFFFFFFF'],
    ['FEDCBA9876543210','0123456789ABCDEF','FFFFFFFFFFFFFFFF'],
    // A^A=A Anything xor itself is 0
    ['00000000FFFFFFFF','00000000FFFFFFFF','0000000000000000'],
    ['C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C','0000000000000000'],
    ['C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C','0000000000000000'],
    ['FEDCBA9876543210','FEDCBA9876543210','0000000000000000'],
    // Other cases
    ['FEDCBA9876543210','0000000FFFFFFFFF','FEDCBA9789ABCDEF'],
    ['C3A5A5A5A5A5A53C','0000000FFFFFFFFF','C3A5A5AA5A5A5AC3'],
    ['FEDCBA9876543210','FFFFFFFFF0000000','0123456786543210'],
    ['C3A5A5A5A5A5A53C','FFFFFFFFF0000000','3C5A5A5A55A5A53C'],
    ['0000000000000001','0000000000000002','0000000000000003'],
    ['0000000000000001','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFE'],
    
    //Mismatched - the first is used as a template, each treated little endian
    ['F00000000000000F','FFEEDDCCBBAA99887766554433221100','876655443322110F'],
    ['F000000000000000000000000000000F','7766554433221100','F000000000000000776655443322110F'],
];
for (const [a,b,expect] of xorTest) {
	tsts(`${a} ^ ${b}`, () => {
		const aBytes = hex.toBytes(a);
		const aUint = UInt.fromBytesBE(aBytes,aBytes.length>>2);
		const bBytes = hex.toBytes(b);
		const bUint = UInt.fromBytesBE(bBytes,bBytes.length>>2);
		const res = aUint.xor(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

// prettier-ignore
const orTest=[
    // A|0=A: Anything or zero is anything
    ['0000000000000000','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['0000000000000000','0123456789ABCDEF','0123456789ABCDEF'],
    ['0000000000000000','FEDCBA9876543210','FEDCBA9876543210'],
    ['0000000000000000','0000000000000000','0000000000000000'],
    // A|1=1:  Anything or 1 is 1
    ['FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFF','0123456789ABCDEF','FFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFF','FEDCBA9876543210','FFFFFFFFFFFFFFFF'],
    // A|~A=1: Anything or its compliment is 1
    ['00000000FFFFFFFF','FFFFFFFF00000000','FFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A53C','3C5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFF'],
    ['C35A5A5A5A5A5A3C','3CA5A5A5A5A5A5C3','FFFFFFFFFFFFFFFF'],
    ['FEDCBA9876543210','0123456789ABCDEF','FFFFFFFFFFFFFFFF'],
    // A|A=A: Anything or itself is itself
    ['00000000FFFFFFFF','00000000FFFFFFFF','00000000FFFFFFFF'],
    ['C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C'],
    ['C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C'],
    ['FEDCBA9876543210','FEDCBA9876543210','FEDCBA9876543210'],
    // Any bits set override the other value (form of masking)
    ['FEDCBA9876543210','0000000FFFFFFFFF','FEDCBA9FFFFFFFFF'],
    ['C3A5A5A5A5A5A53C','0000000FFFFFFFFF','C3A5A5AFFFFFFFFF'],
    ['FEDCBA9876543210','FFFFFFFFF0000000','FFFFFFFFF6543210'],
    ['C3A5A5A5A5A5A53C','FFFFFFFFF0000000','FFFFFFFFF5A5A53C'],
    ['0000000000000001','0000000000000002','0000000000000003'],
    ['0000000000000001','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],

    //Mismatched - the first is used as a template, each treated little endian
    ['F00000000000000F','FFEEDDCCBBAA99887766554433221100','F76655443322110F'],
    ['F000000000000000000000000000000F','7766554433221100','F000000000000000776655443322110F'],
];
for (const [a,b,expect] of orTest) {
	tsts(`${a} | ${b}`, () => {
		const aBytes = hex.toBytes(a);
		const aUint = UInt.fromBytesBE(aBytes,aBytes.length>>2);
		const bBytes = hex.toBytes(b);
		const bUint = UInt.fromBytesBE(bBytes,bBytes.length>>2);
		const res = aUint.or(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

// prettier-ignore
const andTest=[
    // A&0=0: Zero and anything is zero
    ['00000000000000000000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000000'],
    ['00000000000000000000000000000000','0123456789ABCDEF0123456789ABCDEF','00000000000000000000000000000000'],
    ['00000000000000000000000000000000','FEDCBA9876543210FEDCBA9876543210','00000000000000000000000000000000'],
    ['00000000000000000000000000000000','00000000000000000000000000000000','00000000000000000000000000000000'],
    // A&1=A:  All set and anything is anything
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','0123456789ABCDEF0123456789ABCDEF','0123456789ABCDEF0123456789ABCDEF'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA9876543210'],
    // A&~A=0: Anything and its compliment is 0
    ['00000000FFFFFFFFFFFFFFFF00000000','FFFFFFFF0000000000000000FFFFFFFF','00000000000000000000000000000000'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3','00000000000000000000000000000000'],
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','3CA5A5A5A5A5A5A5A5A5A5A5A5A5A5C3','00000000000000000000000000000000'],
    ['FEDCBA9876543210FEDCBA9876543210','0123456789ABCDEF0123456789ABCDEF','00000000000000000000000000000000'],
    // A&A=A: Anything and itself is itself
    ['00000000FFFFFFFF00000000FFFFFFFF','00000000FFFFFFFF00000000FFFFFFFF','00000000FFFFFFFF00000000FFFFFFFF'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C'],
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C'],
    ['FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA9876543210'],
    // Only bits set to true in both survive (form of masking)
    ['FEDCBA9876543210FEDCBA9876543210','000000000000000FFFFFFFFFFFFFFFFF','0000000000000000FEDCBA9876543210'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','000000000000000FFFFFFFFFFFFFFFFF','0000000000000005A5A5A5A5A5A5A53C'],
    ['FEDCBA9876543210FEDCBA9876543210','FFFFFFFFFFFFFFFFF000000000000000','FEDCBA9876543210F000000000000000'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','FFFFFFFFFFFFFFFFF000000000000000','C3A5A5A5A5A5A5A5A000000000000000'],
    ['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000000'],
    ['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000001'],
        
    // A&0=0: Zero and anything is zero
    ['0000000000000000','FFFFFFFFFFFFFFFF','0000000000000000'],
    ['0000000000000000','0123456789ABCDEF','0000000000000000'],
    ['0000000000000000','FEDCBA9876543210','0000000000000000'],
    ['0000000000000000','0000000000000000','0000000000000000'],
    // A&1=A:  All set and anything is anything
    ['FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFF','0123456789ABCDEF','0123456789ABCDEF'],
    ['FFFFFFFFFFFFFFFF','FEDCBA9876543210','FEDCBA9876543210'],
    // A&~A=0: Anything and its compliment is 0
    ['00000000FFFFFFFF','FFFFFFFF00000000','0000000000000000'],
    ['C3A5A5A5A5A5A53C','3C5A5A5A5A5A5AC3','0000000000000000'],
    ['C35A5A5A5A5A5A3C','3CA5A5A5A5A5A5C3','0000000000000000'],
    ['FEDCBA9876543210','0123456789ABCDEF','0000000000000000'],
    // A&A=A: Anything and itself is itself
    ['00000000FFFFFFFF','00000000FFFFFFFF','00000000FFFFFFFF'],
    ['C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C'],
    ['C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C'],
    ['FEDCBA9876543210','FEDCBA9876543210','FEDCBA9876543210'],
    // Only bits set to true in both survive (form of masking)
    ['FEDCBA9876543210','0000000FFFFFFFFF','0000000876543210'],
    ['C3A5A5A5A5A5A53C','0000000FFFFFFFFF','00000005A5A5A53C'],
    ['FEDCBA9876543210','FFFFFFFFF0000000','FEDCBA9870000000'],
    ['C3A5A5A5A5A5A53C','FFFFFFFFF0000000','C3A5A5A5A0000000'],
    ['0000000000000001','0000000000000002','0000000000000000'],
    ['0000000000000001','FFFFFFFFFFFFFFFF','0000000000000001'],

    //Mismatched - the first is used as a template, each treated little endian
    ['F00000000000000F','FFEEDDCCBBAA99887766554433221100','7000000000000000'],
    ['F000000000000000000000000000000F','7766554433221100','00000000000000000000000000000000'],
];
for (const [a,b,expect] of andTest) {
	tsts(`${a} & ${b}`, () => {
		const aBytes = hex.toBytes(a);
		const aUint = UInt.fromBytesBE(aBytes,aBytes.length>>2);
		const bBytes = hex.toBytes(b);
		const bUint = UInt.fromBytesBE(bBytes,bBytes.length>>2);
		const res = aUint.and(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

const notTest = [
	['00000000000000000000000000000000', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	['0000000000000000FFFFFFFFFFFFFFFF', 'FFFFFFFFFFFFFFFF0000000000000000'],
	['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C', '3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3'], //A=1010, 5=0101, C=1100, 3=0011
	['FEDCBA9876543210FEDCBA9876543210', '0123456789ABCDEF0123456789ABCDEF'],

    ['0000000000000000', 'FFFFFFFFFFFFFFFF'],
	['00000000FFFFFFFF', 'FFFFFFFF00000000'],
	['C3A5A5A5A5A5A53C', '3C5A5A5A5A5A5AC3'],
	['FEDCBA9876543210', '0123456789ABCDEF'],
];
for (const [start,expect] of notTest) {
	tsts(`~${start}`, () => {
		const aBytes = hex.toBytes(start);
		const aUint = UInt.fromBytesBE(aBytes,aBytes.length>>2);
		const res = aUint.not();
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
    tsts(`~${expect}`, () => {
		const aBytes = hex.toBytes(expect);
		const aUint = UInt.fromBytesBE(aBytes,aBytes.length>>2);
		const res = aUint.not();
		assert.is(hex.fromBytes(res.toBytesBE()), start);
	});
}

const toStrTest:[string,string][]=[
    ['00000000000000000000000000000000','u128{00000000000000000000000000000000}'],
	['00000000000000000000000000000001','u128{00000000000000000000000000000001}'],
	['10000000000000000000000000000000','u128{10000000000000000000000000000000}'],
	['FEDCBA9876543210FEDCBA9876543210','u128{FEDCBA9876543210FEDCBA9876543210}'],
	['C4D5E6F78091A2B3C4D5E6F78091A2B3','u128{C4D5E6F78091A2B3C4D5E6F78091A2B3}'],
    
    ['0000000000000000','u64{0000000000000000}'],
	['0000000000000001','u64{0000000000000001}'],
	['1000000000000000','u64{1000000000000000}'],
	['FEDCBA9876543210','u64{FEDCBA9876543210}'],
	['C4D5E6F78091A2B3','u64{C4D5E6F78091A2B3}'],

    ['00000000','u32{00000000}'],
    ['00000001','u32{00000001}'],
    ['10000000','u32{10000000}'],
    ['FEDCBA98','u32{FEDCBA98}'],
    ['01234567','u32{01234567}'],
];
for(const [a,expect] of toStrTest) {
	tsts(`${a}.toString`,()=>{
		const aBytes=hex.toBytes(a);
		const aUint = UInt.fromBytesBE(aBytes,aBytes.length>>2);
		assert.is(aUint.toString(),expect);
	});
}

// prettier-ignore
const addTest=[
    // A+0=A: Anything plus zero is anything (like or)
    ['00000000000000000000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['00000000000000000000000000000000','0123456789ABCDEF0123456789ABCDEF','0123456789ABCDEF0123456789ABCDEF'],
    ['00000000000000000000000000000000','FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA9876543210'],
    ['00000000000000000000000000000000','00000000000000000000000000000000','00000000000000000000000000000000'],
    // A+1=A:  Anything plus 1 overflows
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE'],//Overflow
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','0123456789ABCDEF0123456789ABCDEF','0123456789ABCDEF0123456789ABCDEE'],//Overflow
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA987654320F'],//Overflow
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    // A+~A .. is 1 (like or)
    ['0000000000000000FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF0000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','3CA5A5A5A5A5A5A5A5A5A5A5A5A5A5C3','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['FEDCBA9876543210FEDCBA9876543210','0123456789ABCDEF0123456789ABCDEF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    // A+A=2A
    ['0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF','0000000000000001FFFFFFFFFFFFFFFE'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','874B4B4B4B4B4B4B4B4B4B4B4B4B4A78'],//Overflow
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','86B4B4B4B4B4B4B4B4B4B4B4B4B4B478'],//Overflow
    ['FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA9876543210','FDB97530ECA86421FDB97530ECA86420'],//Overflow
    // // Others
    ['FEDCBA9876543210FEDCBA9876543210','000000000000000FFFFFFFFFFFFFFFFF','FEDCBA9876543220FEDCBA987654320F'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','000000000000000FFFFFFFFFFFFFFFFF','C3A5A5A5A5A5A5B5A5A5A5A5A5A5A53B'],
    ['FEDCBA9876543210FEDCBA9876543210','FFFFFFFFFFFFFFFFF000000000000000','FEDCBA9876543210EEDCBA9876543210'],//Overflow
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','FFFFFFFFFFFFFFFFF000000000000000','C3A5A5A5A5A5A5A595A5A5A5A5A5A53C'],//Overflow
    ['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000003'],
    ['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000000'],//Overflow

    // A+0=A: Anything plus zero is anything (like or)
    ['0000000000000000','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['0000000000000000','0123456789ABCDEF','0123456789ABCDEF'],
    ['0000000000000000','FEDCBA9876543210','FEDCBA9876543210'],
    ['0000000000000000','0000000000000000','0000000000000000'],
    // A+1=A:  Anything plus 1 overflows
    ['FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFE'],//Overflow
    ['FFFFFFFFFFFFFFFF','0123456789ABCDEF','0123456789ABCDEE'],//Overflow
    ['FFFFFFFFFFFFFFFF','FEDCBA9876543210','FEDCBA987654320F'],//Overflow
    ['FFFFFFFFFFFFFFFF','0000000000000000','FFFFFFFFFFFFFFFF'],
    // A+~A .. is 1 (like or)
    ['00000000FFFFFFFF','FFFFFFFF00000000','FFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A53C','3C5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFF'],
    ['C35A5A5A5A5A5A3C','3CA5A5A5A5A5A5C3','FFFFFFFFFFFFFFFF'],
    ['FEDCBA9876543210','0123456789ABCDEF','FFFFFFFFFFFFFFFF'],
    // A+A=2A
    ['00000000FFFFFFFF','00000000FFFFFFFF','00000001FFFFFFFE'],
    ['C3A5A5A5A5A5A53C','C3A5A5A5A5A5A53C','874B4B4B4B4B4A78'],//Overflow
    ['C35A5A5A5A5A5A3C','C35A5A5A5A5A5A3C','86B4B4B4B4B4B478'],//Overflow
    ['FEDCBA9876543210','FEDCBA9876543210','FDB97530ECA86420'],//Overflow
    // Others
    ['FEDCBA9876543210','0000000FFFFFFFFF','FEDCBAA87654320F'],
    ['C3A5A5A5A5A5A53C','0000000FFFFFFFFF','C3A5A5B5A5A5A53B'],
    ['FEDCBA9876543210','FFFFFFFFF0000000','FEDCBA9866543210'],//Overflow
    ['C3A5A5A5A5A5A53C','FFFFFFFFF0000000','C3A5A5A595A5A53C'],//Overflow
    ['0000000000000001','0000000000000002','0000000000000003'],
    ['0000000000000001','FFFFFFFFFFFFFFFF','0000000000000000'],//Overflow

    //Mismatched - the first is used as a template, each treated little endian
    ['F000000F','0000000000000000','F000000F'],
    ['00000000FFFFFFFF','00000000','00000000FFFFFFFF'],

];
for (const [a,b,expect] of addTest) {
	tsts(`${a} + ${b}`, () => {
		const aBytes = hex.toBytes(a);
		const aUint = UInt.fromBytesBE(aBytes,aBytes.length>>2);
		const bBytes = hex.toBytes(b);
		const bUint = UInt.fromBytesBE(bBytes,bBytes.length>>2);
		const res = aUint.add(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

const subTest:[number,number,number,string][]=[
	[1,1,4,'00000000000000000000000000000000'],
	[2,1,4,'00000000000000000000000000000001'],
	[0,2,4,'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE'],
	[0xffffffff,1,4,'000000000000000000000000FFFFFFFE'],
	[1,0,4,'00000000000000000000000000000001'],

    [1,1,2,'0000000000000000'],
	[2,1,2,'0000000000000001'],
	[0,2,2,'FFFFFFFFFFFFFFFE'],
	[0xffffffff,1,2,'00000000FFFFFFFE'],
	[1,0,2,'0000000000000001'],
];
for (const [a,b,size,expect] of subTest) {
	tsts(`${a} - ${b}`, () => {
		const aUint = UInt.fromInt(a,size);
		const bUint = UInt.fromInt(b,size);
		const res = aUint.sub(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

// //FFFFFFFFFFFFFFFF
// //0000000000000000

// prettier-ignore
const mulTest=[
	['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000002'],
 	['0000000000000000000000000000FFFF','0000000000000000000000000000FFFF','000000000000000000000000FFFE0001'],
 	['000000000000000000000000000FFFFF','000000000000000000000000000FFFFF','0000000000000000000000FFFFE00001'],
 	['00000000000000000000000000FFFFFF','00000000000000000000000000FFFFFF','00000000000000000000FFFFFE000001'],
 	['0000000000000000000000000FFFFFFF','0000000000000000000000000FFFFFFF','000000000000000000FFFFFFE0000001'],
 	['000000000000000000000000FFFFFFFF','000000000000000000000000FFFFFFFF','0000000000000000FFFFFFFE00000001'],
 	['00000000000000000000000FFFFFFFFF','00000000000000000000000FFFFFFFFF','00000000000000FFFFFFFFE000000001'],
 	['0000000000000000000000FFFFFFFFFF','0000000000000000000000FFFFFFFFFF','000000000000FFFFFFFFFE0000000001'],
 	['000000000000000000000FFFFFFFFFFF','000000000000000000000FFFFFFFFFFF','0000000000FFFFFFFFFFE00000000001'],
 	['00000000000000000000FFFFFFFFFFFF','00000000000000000000FFFFFFFFFFFF','00000000FFFFFFFFFFFE000000000001'],
 	['0000000000000000000FFFFFFFFFFFFF','0000000000000000000FFFFFFFFFFFFF','000000FFFFFFFFFFFFE0000000000001'],
 	['000000000000000000FFFFFFFFFFFFFF','000000000000000000FFFFFFFFFFFFFF','0000FFFFFFFFFFFFFE00000000000001'],
 	['00000000000000000FFFFFFFFFFFFFFF','00000000000000000FFFFFFFFFFFFFFF','00FFFFFFFFFFFFFFE000000000000001'],
 	['0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFE0000000000000001'],
	['0000000000000000000000000000FFFF','00000000000000000000000000000003','0000000000000000000000000002FFFD'],
	['000000000000000000000000000FFFFF','00000000000000000000000000000035','000000000000000000000000034FFFCB'],
	['00000000000000000000000000FFFFFF','00000000000000000000000000000357','00000000000000000000000356FFFCA9'],
	['0000000000000000000000000FFFFFFF','0000000000000000000000000000357B','000000000000000000000357AFFFCA85'],
	['000000000000000000000000FFFFFFFF','000000000000000000000000000357BD','0000000000000000000357BCFFFCA843'],
	['00000000000000000000000FFFFFFFFF','00000000000000000000000000357BDB','00000000000000000357BDAFFFCA8425'],
	['0000000000000000000000FFFFFFFFFF','0000000000000000000000000357BDB7','000000000000000357BDB6FFFCA84249'],
	['000000000000000000000FFFFFFFFFFF','000000000000000000000000357BDB75','0000000000000357BDB74FFFCA84248B'],
	['00000000000000000000FFFFFFFFFFFF','00000000000000000000000357BDB753','00000000000357BDB752FFFCA84248AD'],
	['0000000000000000000FFFFFFFFFFFFF','0000000000000000000000357BDB7535','000000000357BDB7534FFFCA84248ACB'],
	['000000000000000000FFFFFFFFFFFFFF','000000000000000000000357BDB75357','0000000357BDB75356FFFCA84248ACA9'],
	['00000000000000000FFFFFFFFFFFFFFF','00000000000000000000357BDB75357B','00000357BDB75357AFFFCA84248ACA85'],
	['0000000000000000FFFFFFFFFFFFFFFF','0000000000000000000357BDB75357BD','000357BDB75357BCFFFCA84248ACA843'],
 	['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
 	['0000000000000000000000003B9ACA00','0000000000000000000000003B9ACA00','00000000000000000DE0B6B3A7640000'],//1B*1B=1x10^18
 	['7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000010','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0'],//Prove it is unsigned
	['11111111111111111111111111111111','0000000000000000000000000000000F','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
 	['11111111111111111111111111111111','000000000000000000000000000000EE','DDDDDDDDDDDDDDDDDDDDDDDDDDDDDDCE'],
 	['11111111111111111111111111111111','00000000000000000000000000000DDD','999999999999999999999999999998AD'],
 	['11111111111111111111111111111111','0000000000000000000000000000CCCC','3333333333333333333333333333258C'],
 	['11111111111111111111111111111111','000000000000000000000000000BBBBB','AAAAAAAAAAAAAAAAAAAAAAAAAAA9E26B'],
 	['11111111111111111111111111111111','00000000000000000000000000AAAAAA','FFFFFFFFFFFFFFFFFFFFFFFFFFF49F4A'],
 	['11111111111111111111111111111111','00000000000000000000000009999999','333333333333333333333333328F5C29'],
 	['11111111111111111111111111111111','00000000000000000000000088888888','4444444444444444444444443B2A1908'],
 	['11111111111111111111111111111111','00000000000000000000000777777777','333333333333333333333332B3C4D5E7'],
 	['11111111111111111111111111111111','00000000000000000000006666666666','FFFFFFFFFFFFFFFFFFFFFFF92C5F92C6'],
 	['11111111111111111111111111111111','00000000000000000000055555555555','AAAAAAAAAAAAAAAAAAAAAA4FA4FA4FA5'],
 	['11111111111111111111111111111111','00000000000000000000444444444444','333333333333333333332EA61D950C84'],
 	['11111111111111111111111111111111','00000000000000000003333333333333','9999999999999999999962FC962FC963'],
 	['11111111111111111111111111111111','00000000000000000022222222222222','DDDDDDDDDDDDDDDDDDDB97530ECA8642'],
 	['11111111111111111111111111111111','00000000000000000111111111111111','FFFFFFFFFFFFFFFFFFEDCBA987654321'],

    ['0000000000000001','0000000000000002','0000000000000002'],
    ['000000000000FFFF','000000000000FFFF','00000000FFFE0001'],
    ['00000000000FFFFF','00000000000FFFFF','000000FFFFE00001'],
    ['0000000000FFFFFF','0000000000FFFFFF','0000FFFFFE000001'],
    ['000000000FFFFFFF','000000000FFFFFFF','00FFFFFFE0000001'],
    ['00000000FFFFFFFF','00000000FFFFFFFF','FFFFFFFE00000001'],
    ['0000000FFFFFFFFF','0000000FFFFFFFFF','FFFFFFE000000001'],
    ['000000FFFFFFFFFF','000000FFFFFFFFFF','FFFFFE0000000001'],
    ['00000FFFFFFFFFFF','00000FFFFFFFFFFF','FFFFE00000000001'],
    ['0000FFFFFFFFFFFF','0000FFFFFFFFFFFF','FFFE000000000001'],
    ['000FFFFFFFFFFFFF','000FFFFFFFFFFFFF','FFE0000000000001'],
    ['00FFFFFFFFFFFFFF','00FFFFFFFFFFFFFF','FE00000000000001'],
    ['0FFFFFFFFFFFFFFF','0FFFFFFFFFFFFFFF','E000000000000001'],
    ['FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF','0000000000000001'],
    ['000000000000FFFF','0000000000000003','000000000002FFFD'],
    ['00000000000FFFFF','0000000000000035','00000000034FFFCB'],
    ['0000000000FFFFFF','0000000000000357','0000000356FFFCA9'],
    ['000000000FFFFFFF','000000000000357B','00000357AFFFCA85'],
    ['00000000FFFFFFFF','00000000000357BD','000357BCFFFCA843'],
    ['0000000FFFFFFFFF','0000000000357BDB','0357BDAFFFCA8425'],
    ['000000FFFFFFFFFF','000000000357BDB7','57BDB6FFFCA84249'],
    ['00000FFFFFFFFFFF','00000000357BDB75','BDB74FFFCA84248B'],
    ['0000FFFFFFFFFFFF','0000000357BDB753','B752FFFCA84248AD'],
    ['000FFFFFFFFFFFFF','000000357BDB7535','534FFFCA84248ACB'],
    ['00FFFFFFFFFFFFFF','00000357BDB75357','56FFFCA84248ACA9'],
    ['0FFFFFFFFFFFFFFF','0000357BDB75357B','AFFFCA84248ACA85'],
    ['FFFFFFFFFFFFFFFF','000357BDB75357BD','FFFCA84248ACA843'],
    ['0000000000000001','FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF'],
    ['00000000EE6B2800','000000000000000D','0000000C1B710800'],//4B*13 =52B
    ['000000003B9ACA00','000000003B9ACA00','0DE0B6B3A7640000'],//1B*1B=1x10^18
    ['0000000ABCDEF123','000000000BEBA7E9','7FFFFFFF32584DDB'],
    ['7FFFFFFFFFFFFFFF','0000000000000010','FFFFFFFFFFFFFFF0'],//Prove it is unsigned
    ['1111111111111111','000000000000000F','FFFFFFFFFFFFFFFF'],
    ['1111111111111111','00000000000000EE','DDDDDDDDDDDDDDCE'],
    ['1111111111111111','0000000000000DDD','99999999999998AD'],
    ['1111111111111111','000000000000CCCC','333333333333258C'],
    ['1111111111111111','00000000000BBBBB','AAAAAAAAAAA9E26B'],
    ['1111111111111111','0000000000AAAAAA','FFFFFFFFFFF49F4A'],
    ['1111111111111111','0000000009999999','33333333328F5C29'],
    ['1111111111111111','0000000088888888','444444443B2A1908'],
    ['1111111111111111','0000000777777777','33333332B3C4D5E7'],
    ['1111111111111111','0000006666666666','FFFFFFF92C5F92C6'],
    ['1111111111111111','0000055555555555','AAAAAA4FA4FA4FA5'],
    ['1111111111111111','0000444444444444','33332EA61D950C84'],
    ['1111111111111111','0003333333333333','999962FC962FC963'],
    ['1111111111111111','0022222222222222','DDDB97530ECA8642'],
    ['1111111111111111','0111111111111111','FFEDCBA987654321'],
];
for (const [a,b,expect] of mulTest) {
	tsts(`${a} * ${b}`, () => {
		const aBytes = hex.toBytes(a);
		const aUint = UInt.fromBytesBE(aBytes,aBytes.length>>2);
		const bBytes = hex.toBytes(b);
		const bUint = UInt.fromBytesBE(bBytes,bBytes.length>>2);
		const res = aUint.mul(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

const eqTest:[number,number,number,number,boolean][]=[
	[0,2,0,2,true],
	[0,2,1,2,false],
	[0,2,0xffffffff,2,false],

	[1,2,0,2,false],
	[1,2,1,2,true],
	[1,2,0xffffffff,2,false],

	[0xffffffff,2,0,2,false],
	[0xffffffff,2,1,2,false],
	[0xffffffff,2,0xffffffff,2,true],

	//0x00000001 00000001 = 4294967297
	[4294967297,2,0,2,false],
	[4294967297,2,1,2,false],
	[4294967297,2,4294967296,2,false],
	[4294967297,2,4294967297,2,true],

    //Mismatched sizes
    [1,2,1,3,true],
    [1,3,1,1,true],
];
for(const [aInt,aSize,bInt,bSize,expect] of eqTest) {
	tsts(`UInt{${aInt}}==UInt{${bInt}}`,()=>{
		const a=UInt.fromInt(aInt,aSize);
		const b=UInt.fromInt(bInt,bSize);
		assert.is(a.eq(b),expect);
	})
}

const lastByteBETest:[number,number,number][]=[
	[0,2,0],
	[1,2,1],
	[0x1122,2,0x22],
];
for(const [a,size,expect] of lastByteBETest) {
	tsts(`lsb(${a})`,()=>{
		const a64=UInt.fromInt(a,size);
		assert.is(a64.lsb(),expect);
	})
}

const lsbTest:[string,number,number][]=[
	['000102030405060708090A0B0C0D0E0F',0,15],
	['000102030405060708090A0B0C0D0E0F',1,14],
	['000102030405060708090A0B0C0D0E0F',2,13],
	['000102030405060708090A0B0C0D0E0F',3,12],
	['000102030405060708090A0B0C0D0E0F',4,11],
	['000102030405060708090A0B0C0D0E0F',5,10],
	['000102030405060708090A0B0C0D0E0F',6,9],
	['000102030405060708090A0B0C0D0E0F',7,8],
	['000102030405060708090A0B0C0D0E0F',8,7],
    ['000102030405060708090A0B0C0D0E0F',9,6],
    ['000102030405060708090A0B0C0D0E0F',10,5],
    ['000102030405060708090A0B0C0D0E0F',11,4],
    ['000102030405060708090A0B0C0D0E0F',12,3],
    ['000102030405060708090A0B0C0D0E0F',13,2],
    ['000102030405060708090A0B0C0D0E0F',14,1],
    ['000102030405060708090A0B0C0D0E0F',15,0],
    ['000102030405060708090A0B0C0D0E0F',16,15],//Same as 0 because of &15
]
for(const [a,lsb,expect] of lsbTest){
	tsts(`lsb(${a},$lsb)`,()=>{
		const aBytes = hex.toBytes(a);
		const aUint = UInt.fromBytesBE(aBytes,aBytes.length>>2);
		assert.is(aUint.lsb(lsb),expect);
	})
}

tsts(`subEq-oversized-throws`,()=>{
    const a=UInt.fromUint32Set(0);
    assert.throws(()=>a.sub(UInt.fromUint32Set(0,0)));
});

tsts(`fromUint32Set`,()=>{
    const a=UInt.fromUint32Set(0x76543210, 0xfedcba98);
    assert.is(a.toString(),'u64{FEDCBA9876543210}');
});


tsts(`clone`,()=>{
	//Really just for coverage (since you cannot mutate, what's the value of a clone?)
	const a=UInt.fromBytesLE(Uint8Array.of(1,0,0,0),4);
    const b=a.clone();
	assert.equal(a.eq(b),true,'Equal in value');
    assert.is(a===b,false,'Not the same object');
});

tsts(`cloneSize`,()=>{
	//Really just for coverage (since you cannot mutate, what's the value of a clone?)
	const a=UInt.fromArray(Uint32Array.of(1,0,0,0),4);
    const b=a.cloneSize(2);
	assert.equal(a.eq(b),true,'Equal in value');
    assert.is(a===b,false,'Not the same object');
});

tsts(`fromArray`,()=>{
	const a=UInt.fromArray(Uint32Array.of(1,0,0,0),2);
	assert.equal(a.eq(UInt.fromIntUnsafe(1,2)),true);
});

tsts(`constants`,()=>{
    const u64=UInt.fromInt(13,2);
	assert.equal(UInt.maxSize(4).toBytesBE(),Uint8Array.of(0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff));
	assert.equal(UInt.minSize(2).toBytesLE(),new Uint8Array(8));
	assert.equal(UInt.zeroSize(2).toBytesLE(),new Uint8Array(8));
})

tsts(`mut`,()=>{
    const u32=UInt.fromInt(13,1);
    const mut=u32.mut();
    mut.addEq(UInt.fromInt(1,1));
    assert.equal(hex.fromBytes(u32.toBytesBE()),'0000000D');
});

tsts.run();
