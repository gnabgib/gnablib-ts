import { suite } from 'uvu';
import * as assert from 'uvu/assert';
import { hex } from '../../../src/codec';
import { U128, U64 } from '../../../src/primitive/number';
import util from 'util';

const tsts = suite('U128');

// prettier-ignore
const xorTest=[
    // A^0=A: Anything xor zero is anything
    ['00000000000000000000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['00000000000000000000000000000000','0123456789ABCDEF0123456789ABCDEF','0123456789ABCDEF0123456789ABCDEF'],
    ['00000000000000000000000000000000','FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA9876543210'],
    ['00000000000000000000000000000000','00000000000000000000000000000000','00000000000000000000000000000000'],
    // A^1=~A:  Anything XOR 1 is its compliment
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000000'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','0123456789ABCDEF0123456789ABCDEF','FEDCBA9876543210FEDCBA9876543210'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FEDCBA9876543210FEDCBA9876543210','0123456789ABCDEF0123456789ABCDEF'],
    // A^~A=1 Anything xor its compliment is 1
    ['0000000000000000FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF0000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','3CA5A5A5A5A5A5A5A5A5A5A5A5A5A5C3','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['FEDCBA98765432100123456789ABCDEF','0123456789ABCDEFFEDCBA9876543210','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    // A^A=A Anything xor itself is 0
    ['0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF','00000000000000000000000000000000'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','00000000000000000000000000000000'],
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','00000000000000000000000000000000'],
    ['FEDCBA98765432100123456789ABCDEF','FEDCBA98765432100123456789ABCDEF','00000000000000000000000000000000'],
    // Other cases
    ['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000003'],
    ['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE'],
];
for (const [a,b,expect] of xorTest) {
	tsts(`${a} ^ ${b}`, () => {
		const aBytes = hex.toBytes(a);
		const aUint = U128.fromBytesBE(aBytes);
		const bBytes = hex.toBytes(b);
		const bUint = U128.fromBytesBE(bBytes);
		const res = aUint.xor(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

// prettier-ignore
const orTest=[
    // A|0=A: Anything or zero is anything
    ['00000000000000000000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['00000000000000000000000000000000','0123456789ABCDEF0123456789ABCDEF','0123456789ABCDEF0123456789ABCDEF'],
    ['00000000000000000000000000000000','FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA9876543210'],
    ['00000000000000000000000000000000','00000000000000000000000000000000','00000000000000000000000000000000'],
    // A|1=1:  Anything or 1 is 1
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','0123456789ABCDEF0123456789ABCDEF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FEDCBA9876543210FEDCBA9876543210','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    // A|~A=1: Anything or its compliment is 1
    ['0000000000000000FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF0000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['FEDCBA98765432100123456789ABCDEF','0123456789ABCDEFFEDCBA9876543210','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    // A|A=A: Anything or itself is itself
    ['0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF'],
    ['3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3','3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3','3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C'],
    ['FEDCBA98765432100123456789ABCDEF','FEDCBA98765432100123456789ABCDEF','FEDCBA98765432100123456789ABCDEF'],
    // Any bits set override the other value (form of masking)
    ['FEDCBA9876543210FEDCBA9876543210','0000000000000000FFFFFFFFFFFFFFFF','FEDCBA9876543210FFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','0000000000000000FFFFFFFFFFFFFFFF','C3A5A5A5A5A5A5A5FFFFFFFFFFFFFFFF'],
    ['FEDCBA9876543210FEDCBA9876543210','FFFFFFFFFFFFFFFF0000000000000000','FFFFFFFFFFFFFFFFFEDCBA9876543210'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','FFFFFFFFFFFFFFFF0000000000000000','FFFFFFFFFFFFFFFFA5A5A5A5A5A5A53C'],

    ['00000000000000010000000000000001','00000000000000000000000000000002','00000000000000010000000000000003'],
    ['00000000000000010000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
];
for (const [a,b,expect] of orTest) {
	tsts(`${a} | ${b}`, () => {
		const aBytes = hex.toBytes(a);
		const aUint = U128.fromBytesBE(aBytes);
		const bBytes = hex.toBytes(b);
		const bUint = U128.fromBytesBE(bBytes);
		const res = aUint.or(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

// prettier-ignore
const andTest=[
    // A&0=0: Zero and anything is zero
    ['00000000000000000000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000000'],
    ['00000000000000000000000000000000','0123456789ABCDEF0000000000000000','00000000000000000000000000000000'],
    ['00000000000000000000000000000000','0000000000000000FEDCBA9876543210','00000000000000000000000000000000'],
    ['00000000000000000000000000000000','00000000000000000000000000000000','00000000000000000000000000000000'],
    // A&1=A:  All set and anything is anything
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','0123456789ABCDEFF0F0F0F0F0F0F0F0','0123456789ABCDEFF0F0F0F0F0F0F0F0'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FEDCBA9876543210F0F0F0F0F0F0F0F0','FEDCBA9876543210F0F0F0F0F0F0F0F0'],
    // A&~A=0: Anything and its compliment is 0
    ['0000000000000000FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF0000000000000000','00000000000000000000000000000000'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3','00000000000000000000000000000000'],
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','3CA5A5A5A5A5A5A5A5A5A5A5A5A5A5C3','00000000000000000000000000000000'],
    ['FEDCBA98765432100123456789ABCDEF','0123456789ABCDEFFEDCBA9876543210','00000000000000000000000000000000'],
    // A&A=A: Anything and itself is itself
    ['0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C'],
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C'],
    ['FEDCBA98765432100123456789ABCDEF','FEDCBA98765432100123456789ABCDEF','FEDCBA98765432100123456789ABCDEF'],
    // Only bits set to true in both survive (form of masking)
    ['FEDCBA9876543210FEDCBA9876543210','00000000000000000000000FFFFFFFFF','00000000000000000000000876543210'],
    ['FEDCBA9876543210FEDCBA9876543210','FFFFFFFFF00000000000000000000000','FEDCBA98700000000000000000000000'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','0000000000000000FFFFFFFFFFFFFFFF','0000000000000000A5A5A5A5A5A5A53C'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','FFFFFFFFFFFFFFFF0000000000000000','C3A5A5A5A5A5A5A50000000000000000'],
    ['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000000'],
    ['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000001'],
];
for (const [a,b,expect] of andTest) {
	tsts(`${a} & ${b}`, () => {
		const aBytes = hex.toBytes(a);
		const aUint = U128.fromBytesBE(aBytes);
		const bBytes = hex.toBytes(b);
		const bUint = U128.fromBytesBE(bBytes);
		const res = aUint.and(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

const notTest = [
	['00000000000000000000000000000000', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['00000000000000000000000000000001', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE'],
    ['10000000000000000000000000000000', 'EFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	['00000000FFFFFFFF00000000FFFFFFFF', 'FFFFFFFF00000000FFFFFFFF00000000'],
    ['0000000000000000FFFFFFFFFFFFFFFF', 'FFFFFFFFFFFFFFFF0000000000000000'],
	['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C', '3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3'], //A=1010, 5=0101, C=1100, 3=0011
    ['FEDCBA9876543210FEDCBA9876543210', '0123456789ABCDEF0123456789ABCDEF'],
];
for (const [start,expect] of notTest) {
    tsts(`~${start}`, () => {
        const aBytes = hex.toBytes(start);
        const aUint = U128.fromBytesBE(aBytes);
		const res = aUint.not();
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
	tsts(`~${expect}`, () => {
        const bBytes=hex.toBytes(expect);
		const bUint = U128.fromBytesBE(bBytes);
		const res = bUint.not();
		assert.is(hex.fromBytes(res.toBytesBE()), start);
	});
}

const lShiftTest:[string,number,string][] = [
	['00000000000000000000000000000000', 0, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 1, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 13, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 32, '00000000000000000000000000000000'],

	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 0, 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 1, 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 13, 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFE000'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 32, 'FFFFFFFFFFFFFFFFFFFFFFFF00000000'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 64, 'FFFFFFFFFFFFFFFF0000000000000000'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 127, '80000000000000000000000000000000'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 128, '00000000000000000000000000000000'],

	['FEDCBA9876543210FEDCBA9876543210', 0, 'FEDCBA9876543210FEDCBA9876543210'],
	['FEDCBA9876543210FEDCBA9876543210', 1, 'FDB97530ECA86421FDB97530ECA86420'],
	['FEDCBA9876543210FEDCBA9876543210', 4, 'EDCBA9876543210FEDCBA98765432100'],
	['FEDCBA9876543210FEDCBA9876543210', 8, 'DCBA9876543210FEDCBA987654321000'],
	['FEDCBA9876543210FEDCBA9876543210', 16, 'BA9876543210FEDCBA98765432100000'],
	['FEDCBA9876543210FEDCBA9876543210', 24, '9876543210FEDCBA9876543210000000'],
	['FEDCBA9876543210FEDCBA9876543210', 28, '876543210FEDCBA98765432100000000'],
	['FEDCBA9876543210FEDCBA9876543210', 31, '3B2A19087F6E5D4C3B2A190800000000'],
	['FEDCBA9876543210FEDCBA9876543210', 32, '76543210FEDCBA987654321000000000'],
	['FEDCBA9876543210FEDCBA9876543210', 33, 'ECA86421FDB97530ECA8642000000000'],
	['FEDCBA9876543210FEDCBA9876543210', 36, '6543210FEDCBA9876543210000000000'],
	['FEDCBA9876543210FEDCBA9876543210', 48, '3210FEDCBA9876543210000000000000'],
	['FEDCBA9876543210FEDCBA9876543210', 63, '7F6E5D4C3B2A19080000000000000000'],
	['FEDCBA9876543210FEDCBA9876543210', 64, 'FEDCBA98765432100000000000000000'],
    ['FEDCBA9876543210FEDCBA9876543210', 128, '00000000000000000000000000000000'],
    //We can exceed size with shifts
    ['FEDCBA9876543210FEDCBA9876543210', 129, '00000000000000000000000000000000'],
    ['FEDCBA9876543210FEDCBA9876543210', 160, '00000000000000000000000000000000'],
    ['FEDCBA9876543210FEDCBA9876543210', 256, '00000000000000000000000000000000'],
];
for (const [start,by,expect] of lShiftTest) {
	tsts(`${start} << ${by}`, () => {
		const aBytes = hex.toBytes(start);
		const a = U128.fromBytesBE(aBytes);
		const res = a.lShift(by);
		//console.log('start',start,'res',res);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

const lRotTest:[string,number,string][] = [
	['00000000000000000000000000000000', 0, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 1, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 13, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 32, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 64, '00000000000000000000000000000000'],
    ['00000000000000000000000000000000', 128, '00000000000000000000000000000000'],

	['FEDCBA9876543210FEDCBA9876543210', 0, 'FEDCBA9876543210FEDCBA9876543210'],
	['FEDCBA9876543210FEDCBA9876543210', 1, 'FDB97530ECA86421FDB97530ECA86421'],
	['FEDCBA9876543210FEDCBA9876543210', 4, 'EDCBA9876543210FEDCBA9876543210F'],
	['FEDCBA9876543210FEDCBA9876543210', 8, 'DCBA9876543210FEDCBA9876543210FE'],
	['FEDCBA9876543210FEDCBA9876543210', 12, 'CBA9876543210FEDCBA9876543210FED'],
	['FEDCBA9876543210FEDCBA9876543210', 16, 'BA9876543210FEDCBA9876543210FEDC'],
	['FEDCBA9876543210FEDCBA9876543210', 20, 'A9876543210FEDCBA9876543210FEDCB'],
	['FEDCBA9876543210FEDCBA9876543210', 24, '9876543210FEDCBA9876543210FEDCBA'],
	['FEDCBA9876543210FEDCBA9876543210', 28, '876543210FEDCBA9876543210FEDCBA9'],
	['FEDCBA9876543210FEDCBA9876543210', 31, '3B2A19087F6E5D4C3B2A19087F6E5D4C'],
	['FEDCBA9876543210FEDCBA9876543210', 32, '76543210FEDCBA9876543210FEDCBA98'],
	['FEDCBA9876543210FEDCBA9876543210', 33, 'ECA86421FDB97530ECA86421FDB97530'],
	['FEDCBA9876543210FEDCBA9876543210', 36, '6543210FEDCBA9876543210FEDCBA987'],
	['FEDCBA9876543210FEDCBA9876543210', 40, '543210FEDCBA9876543210FEDCBA9876'],
	['FEDCBA9876543210FEDCBA9876543210', 44, '43210FEDCBA9876543210FEDCBA98765'],
	['FEDCBA9876543210FEDCBA9876543210', 48, '3210FEDCBA9876543210FEDCBA987654'],
	['FEDCBA9876543210FEDCBA9876543210', 52, '210FEDCBA9876543210FEDCBA9876543'],
	['FEDCBA9876543210FEDCBA9876543210', 56, '10FEDCBA9876543210FEDCBA98765432'],
	['FEDCBA9876543210FEDCBA9876543210', 60, '0FEDCBA9876543210FEDCBA987654321'],
	['FEDCBA9876543210FEDCBA9876543210', 63, '7F6E5D4C3B2A19087F6E5D4C3B2A1908'],
	['FEDCBA9876543210FEDCBA9876543210', 64, 'FEDCBA9876543210FEDCBA9876543210'],
    ['FEDCBA9876543210FEDCBA9876543210', 128, 'FEDCBA9876543210FEDCBA9876543210'],

	['0123456789ABCDEF0123456789ABCDEF', 0, '0123456789ABCDEF0123456789ABCDEF'],
	['0123456789ABCDEF0123456789ABCDEF', 1, '02468ACF13579BDE02468ACF13579BDE'],
	['0123456789ABCDEF0123456789ABCDEF', 4, '123456789ABCDEF0123456789ABCDEF0'],
	['0123456789ABCDEF0123456789ABCDEF', 8, '23456789ABCDEF0123456789ABCDEF01'],
	['0123456789ABCDEF0123456789ABCDEF', 12, '3456789ABCDEF0123456789ABCDEF012'],
	['0123456789ABCDEF0123456789ABCDEF', 16, '456789ABCDEF0123456789ABCDEF0123'],
	['0123456789ABCDEF0123456789ABCDEF', 20, '56789ABCDEF0123456789ABCDEF01234'],
	['0123456789ABCDEF0123456789ABCDEF', 24, '6789ABCDEF0123456789ABCDEF012345'],
	['0123456789ABCDEF0123456789ABCDEF', 28, '789ABCDEF0123456789ABCDEF0123456'],
	['0123456789ABCDEF0123456789ABCDEF', 31, 'C4D5E6F78091A2B3C4D5E6F78091A2B3'],
	['0123456789ABCDEF0123456789ABCDEF', 32, '89ABCDEF0123456789ABCDEF01234567'],
	['0123456789ABCDEF0123456789ABCDEF', 33, '13579BDE02468ACF13579BDE02468ACF'],
	['0123456789ABCDEF0123456789ABCDEF', 36, '9ABCDEF0123456789ABCDEF012345678'],
	['0123456789ABCDEF0123456789ABCDEF', 40, 'ABCDEF0123456789ABCDEF0123456789'],
	['0123456789ABCDEF0123456789ABCDEF', 44, 'BCDEF0123456789ABCDEF0123456789A'],
	['0123456789ABCDEF0123456789ABCDEF', 48, 'CDEF0123456789ABCDEF0123456789AB'],
	['0123456789ABCDEF0123456789ABCDEF', 52, 'DEF0123456789ABCDEF0123456789ABC'],
	['0123456789ABCDEF0123456789ABCDEF', 56, 'EF0123456789ABCDEF0123456789ABCD'],
	['0123456789ABCDEF0123456789ABCDEF', 60, 'F0123456789ABCDEF0123456789ABCDE'],
	['0123456789ABCDEF0123456789ABCDEF', 63, '8091A2B3C4D5E6F78091A2B3C4D5E6F7'],
	['0123456789ABCDEF0123456789ABCDEF', 64, '0123456789ABCDEF0123456789ABCDEF'],
    ['0123456789ABCDEF0123456789ABCDEF', 127, '8091A2B3C4D5E6F78091A2B3C4D5E6F7'],
    ['0123456789ABCDEF0123456789ABCDEF', 128, '0123456789ABCDEF0123456789ABCDEF'],
    //We can exceed
    ['0123456789ABCDEF0123456789ABCDEF', 129, '02468ACF13579BDE02468ACF13579BDE'],
    ['0123456789ABCDEF0123456789ABCDEF', -1, '8091A2B3C4D5E6F78091A2B3C4D5E6F7'],
];
for (const [start,by,expect] of lRotTest) {
	tsts(`${start} ROL ${by}`, () => {
		const aBytes = hex.toBytes(start);
		const a = U128.fromBytesBE(aBytes);
		const res = a.lRot(by);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

const rShiftTest:[string,number,string][] = [
	['00000000000000000000000000000000', 0, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 1, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 13, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 32, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 64, '00000000000000000000000000000000'],
    ['00000000000000000000000000000000', 128, '00000000000000000000000000000000'],

	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 0, 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 1, '7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 13, '0007FFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 32, '00000000FFFFFFFFFFFFFFFFFFFFFFFF'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 64, '0000000000000000FFFFFFFFFFFFFFFF'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 126, '00000000000000000000000000000003'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 127, '00000000000000000000000000000001'],
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF', 128, '00000000000000000000000000000000'],

	['0123456789ABCDEFFEDCBA9876543210', 0, '0123456789ABCDEFFEDCBA9876543210'],
	['0123456789ABCDEFFEDCBA9876543210', 1, '0091A2B3C4D5E6F7FF6E5D4C3B2A1908'],
	['0123456789ABCDEFFEDCBA9876543210', 4, '00123456789ABCDEFFEDCBA987654321'],
	['0123456789ABCDEFFEDCBA9876543210', 8, '000123456789ABCDEFFEDCBA98765432'],
	['0123456789ABCDEFFEDCBA9876543210', 16, '00000123456789ABCDEFFEDCBA987654'],
	['0123456789ABCDEFFEDCBA9876543210', 24, '0000000123456789ABCDEFFEDCBA9876'],
	['0123456789ABCDEFFEDCBA9876543210', 28, '00000000123456789ABCDEFFEDCBA987'],
	['0123456789ABCDEFFEDCBA9876543210', 31, '0000000002468ACF13579BDFFDB97530'],
	['0123456789ABCDEFFEDCBA9876543210', 32, '000000000123456789ABCDEFFEDCBA98'],
	['0123456789ABCDEFFEDCBA9876543210', 33, '000000000091A2B3C4D5E6F7FF6E5D4C'],
	['0123456789ABCDEFFEDCBA9876543210', 36, '0000000000123456789ABCDEFFEDCBA9'],
	['0123456789ABCDEFFEDCBA9876543210', 48, '0000000000000123456789ABCDEFFEDC'],
	['0123456789ABCDEFFEDCBA9876543210', 63, '000000000000000002468ACF13579BDF'],
	['0123456789ABCDEFFEDCBA9876543210', 64, '00000000000000000123456789ABCDEF'],

	['0123456789ABCDEF0123456789ABCDEF', 0, '0123456789ABCDEF0123456789ABCDEF'],
	['0123456789ABCDEF0123456789ABCDEF', 1, '0091A2B3C4D5E6F78091A2B3C4D5E6F7'],
	['0123456789ABCDEF0123456789ABCDEF', 4, '00123456789ABCDEF0123456789ABCDE'],
	['0123456789ABCDEF0123456789ABCDEF', 8, '000123456789ABCDEF0123456789ABCD'],
	['0123456789ABCDEF0123456789ABCDEF', 16, '00000123456789ABCDEF0123456789AB'],
	['0123456789ABCDEF0123456789ABCDEF', 24, '0000000123456789ABCDEF0123456789'],
	['0123456789ABCDEF0123456789ABCDEF', 28, '00000000123456789ABCDEF012345678'],
	['0123456789ABCDEF0123456789ABCDEF', 31, '0000000002468ACF13579BDE02468ACF'],
	['0123456789ABCDEF0123456789ABCDEF', 32, '000000000123456789ABCDEF01234567'],
	['0123456789ABCDEF0123456789ABCDEF', 33, '000000000091A2B3C4D5E6F78091A2B3'],
	['0123456789ABCDEF0123456789ABCDEF', 48, '0000000000000123456789ABCDEF0123'],
	['0123456789ABCDEF0123456789ABCDEF', 63, '000000000000000002468ACF13579BDE'],
	['0123456789ABCDEF0123456789ABCDEF', 64, '00000000000000000123456789ABCDEF'],
    ['0123456789ABCDEF0123456789ABCDEF', 128, '00000000000000000000000000000000'],
    //We can exceed size with shifts
    ['0123456789ABCDEF0123456789ABCDEF', 129, '00000000000000000000000000000000'],
    ['0123456789ABCDEF0123456789ABCDEF', 160, '00000000000000000000000000000000'],
    ['0123456789ABCDEF0123456789ABCDEF', 256, '00000000000000000000000000000000'],

];
for (const [start,by,expect] of rShiftTest) {
	//Note JS has >> (sign aware) and >>> (zero fill) right shift,
	// but since this is an unsigned int, they have the same meaning
	tsts(`${start} >>> ${by}`, () => {
		const aBytes = hex.toBytes(start);
		const a = U128.fromBytesBE(aBytes);
		const res = a.rShift(by);
		//console.log('start',start,'res',res);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

const rRotTest:[string,number,string][] = [
	['00000000000000000000000000000000', 0, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 1, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 13, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 32, '00000000000000000000000000000000'],
	['00000000000000000000000000000000', 64, '00000000000000000000000000000000'],

	['0123456789ABCDEFFEDCBA9876543210', 0, '0123456789ABCDEFFEDCBA9876543210'],
	['0123456789ABCDEFFEDCBA9876543210', 1, '0091A2B3C4D5E6F7FF6E5D4C3B2A1908'],
	['0123456789ABCDEFFEDCBA9876543210', 4, '00123456789ABCDEFFEDCBA987654321'],
	['0123456789ABCDEFFEDCBA9876543210', 8, '100123456789ABCDEFFEDCBA98765432'],
	['0123456789ABCDEFFEDCBA9876543210', 12, '2100123456789ABCDEFFEDCBA9876543'],
	['0123456789ABCDEFFEDCBA9876543210', 16, '32100123456789ABCDEFFEDCBA987654'],
	['0123456789ABCDEFFEDCBA9876543210', 20, '432100123456789ABCDEFFEDCBA98765'],
	['0123456789ABCDEFFEDCBA9876543210', 24, '5432100123456789ABCDEFFEDCBA9876'],
	['0123456789ABCDEFFEDCBA9876543210', 28, '65432100123456789ABCDEFFEDCBA987'],
	['0123456789ABCDEFFEDCBA9876543210', 31, 'ECA8642002468ACF13579BDFFDB97530'],
	['0123456789ABCDEFFEDCBA9876543210', 32, '765432100123456789ABCDEFFEDCBA98'],
	['0123456789ABCDEFFEDCBA9876543210', 33, '3B2A19080091A2B3C4D5E6F7FF6E5D4C'],
	['0123456789ABCDEFFEDCBA9876543210', 36, '8765432100123456789ABCDEFFEDCBA9'],
	['0123456789ABCDEFFEDCBA9876543210', 40, '98765432100123456789ABCDEFFEDCBA'],
	['0123456789ABCDEFFEDCBA9876543210', 44, 'A98765432100123456789ABCDEFFEDCB'],
	['0123456789ABCDEFFEDCBA9876543210', 48, 'BA98765432100123456789ABCDEFFEDC'],
	['0123456789ABCDEFFEDCBA9876543210', 52, 'CBA98765432100123456789ABCDEFFED'],
	['0123456789ABCDEFFEDCBA9876543210', 56, 'DCBA98765432100123456789ABCDEFFE'],
	['0123456789ABCDEFFEDCBA9876543210', 60, 'EDCBA98765432100123456789ABCDEFF'],
	['0123456789ABCDEFFEDCBA9876543210', 63, 'FDB97530ECA8642002468ACF13579BDF'],
	['0123456789ABCDEFFEDCBA9876543210', 64, 'FEDCBA98765432100123456789ABCDEF'],
    ['0123456789ABCDEFFEDCBA9876543210', 127, '02468ACF13579BDFFDB97530ECA86420'],
    ['0123456789ABCDEFFEDCBA9876543210', 128, '0123456789ABCDEFFEDCBA9876543210'],
	//We can exceed
    ['0123456789ABCDEFFEDCBA9876543210', 129, '0091A2B3C4D5E6F7FF6E5D4C3B2A1908'],//=1
    ['0123456789ABCDEFFEDCBA9876543210', -1, '02468ACF13579BDFFDB97530ECA86420'],//=127
];
for (const [start,by,expect] of rRotTest) {
	tsts(`${start} ROR ${by}`, () => {
		const aBytes = hex.toBytes(start);
		const a = U128.fromBytesBE(aBytes);
		const res = a.rRot(by);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

const toStrTest=[
	'00000000000000000000000000000000',
	'00000000000000000000000000000001',
	'10000000000000000000000000000000',
	'FEDCBA98765432100000000000000000',
    '00000000000000000FEDCBA987654321',
	'C4D5E6F78091A2B30000000000000000',
    '0000000000000000C4D5E6F78091A2B3',
];
for(const expect of toStrTest) {
	tsts(`${expect}.toString`,()=>{
		const aBytes=hex.toBytes(expect);
		const a128=U128.fromBytesBE(aBytes);
		assert.is(a128.toString(),expect);
	});
}

// prettier-ignore
const addTest=[
    // A+0=A: Anything plus zero is anything (like or)
    ['00000000000000000000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['00000000000000000000000000000000','0123456789ABCDEF0123456789ABCDEF','0123456789ABCDEF0123456789ABCDEF'],
    ['00000000000000000000000000000000','FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA9876543210'],
    ['00000000000000000000000000000000','00000000000000000000000000000000','00000000000000000000000000000000'],
    // A+1=A:  Anything plus 1 overflows
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE'],//Overflow
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','0123456789ABCDEF0123456789ABCDEF','0123456789ABCDEF0123456789ABCDEE'],//Overflow
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA987654320F'],//Overflow
    ['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    // A+~A .. is 1 (like or)
    ['0000000000000000FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF0000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','3CA5A5A5A5A5A5A5A5A5A5A5A5A5A5C3','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['FEDCBA98765432100123456789ABCDEF','0123456789ABCDEFFEDCBA9876543210','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    // A+A=2A
    ['0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF','0000000000000001FFFFFFFFFFFFFFFE'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','874B4B4B4B4B4B4B4B4B4B4B4B4B4A78'],//Overflow
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','86B4B4B4B4B4B4B4B4B4B4B4B4B4B478'],//Overflow
    ['FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA9876543210','FDB97530ECA86421FDB97530ECA86420'],//Overflow
    // // Others
    ['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000003'],
    ['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000000'],//Overflow
];
for (const [a,b,expect] of addTest) {
	tsts(`${a} + ${b}`, () => {
		const aBytes = hex.toBytes(a);
		const aUint = U128.fromBytesBE(aBytes);
		const bBytes = hex.toBytes(b);
		const bUint = U128.fromBytesBE(bBytes);
		const res = aUint.add(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

const subTest:[number,number,string][]=[
	[1,1,'00000000000000000000000000000000'],
	[2,1,'00000000000000000000000000000001'],
    [0,1,'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	[0,2,'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE'],
	[0xffffffff,1,'000000000000000000000000FFFFFFFE'],
	[1,0,'00000000000000000000000000000001'],
];
for (const [a,b,expect] of subTest) {
	tsts(`${a} - ${b}`, () => {
		const aUint = U128.fromInt(a);
		const bUint = U128.fromInt(b);
		const res = aUint.sub(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

// prettier-ignore
const mulTest=[
	['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000002'],
    ['0000000000000000000000000000000F','0000000000000000000000000000000F','000000000000000000000000000000E1'],
    ['000000000000000000000000000000FF','000000000000000000000000000000FF','0000000000000000000000000000FE01'],
    ['00000000000000000000000000000FFF','00000000000000000000000000000FFF','00000000000000000000000000FFE001'],
	['0000000000000000000000000000FFFF','0000000000000000000000000000FFFF','000000000000000000000000FFFE0001'],
	['000000000000000000000000000FFFFF','000000000000000000000000000FFFFF','0000000000000000000000FFFFE00001'],
	['00000000000000000000000000FFFFFF','00000000000000000000000000FFFFFF','00000000000000000000FFFFFE000001'],
	['0000000000000000000000000FFFFFFF','0000000000000000000000000FFFFFFF','000000000000000000FFFFFFE0000001'],//0000000000000000
	['000000000000000000000000FFFFFFFF','000000000000000000000000FFFFFFFF','0000000000000000FFFFFFFE00000001'],
	['00000000000000000000000FFFFFFFFF','00000000000000000000000FFFFFFFFF','00000000000000FFFFFFFFE000000001'],
	['0000000000000000000000FFFFFFFFFF','0000000000000000000000FFFFFFFFFF','000000000000FFFFFFFFFE0000000001'],
	['000000000000000000000FFFFFFFFFFF','000000000000000000000FFFFFFFFFFF','0000000000FFFFFFFFFFE00000000001'],
	['00000000000000000000FFFFFFFFFFFF','00000000000000000000FFFFFFFFFFFF','00000000FFFFFFFFFFFE000000000001'],
	['0000000000000000000FFFFFFFFFFFFF','0000000000000000000FFFFFFFFFFFFF','000000FFFFFFFFFFFFE0000000000001'],
	['000000000000000000FFFFFFFFFFFFFF','000000000000000000FFFFFFFFFFFFFF','0000FFFFFFFFFFFFFE00000000000001'],
	['00000000000000000FFFFFFFFFFFFFFF','00000000000000000FFFFFFFFFFFFFFF','00FFFFFFFFFFFFFFE000000000000001'],
    ['0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFE0000000000000001'],
    ['000000000000000FFFFFFFFFFFFFFFFF','000000000000000FFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFE00000000000000001'],
    ['00000000000000FFFFFFFFFFFFFFFFFF','00000000000000FFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFE000000000000000001'],
    ['0000000000000FFFFFFFFFFFFFFFFFFF','0000000000000FFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFE0000000000000000001'],
    ['000000000000FFFFFFFFFFFFFFFFFFFF','000000000000FFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFE00000000000000000001'],
    ['00000000000FFFFFFFFFFFFFFFFFFFFF','00000000000FFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFE000000000000000000001'],
    ['0000000000FFFFFFFFFFFFFFFFFFFFFF','0000000000FFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFE0000000000000000000001'],
    ['000000000FFFFFFFFFFFFFFFFFFFFFFF','000000000FFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFE00000000000000000000001'],
    ['00000000FFFFFFFFFFFFFFFFFFFFFFFF','00000000FFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFE000000000000000000000001'],
    ['0000000FFFFFFFFFFFFFFFFFFFFFFFFF','0000000FFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFE0000000000000000000000001'],
    ['000000FFFFFFFFFFFFFFFFFFFFFFFFFF','000000FFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFE00000000000000000000000001'],
    ['00000FFFFFFFFFFFFFFFFFFFFFFFFFFF','00000FFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFE000000000000000000000000001'],
    ['0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF','0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFE0000000000000000000000000001'],
    ['000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF','000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFE00000000000000000000000000001'],
    ['00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FE000000000000000000000000000001'],
    ['0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','E0000000000000000000000000000001'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000001'],
	['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	['7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000010','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0'],//Prove it is unsigned
];
for (const [a,b,expect] of mulTest) {
	tsts(`${a} * ${b}`, () => {
		const aBytes = hex.toBytes(a);
		const aUint = U128.fromBytesBE(aBytes);
		const bBytes = hex.toBytes(b);
		const bUint = U128.fromBytesBE(bBytes);
		const res = aUint.mul(bUint);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
	});
}

const eqTest:[number,number,boolean][]=[
	[0,0,true],
	[0,1,false],
	[0,0xffffffff,false],

	[1,0,false],
	[1,1,true],
	[1,0xffffffff,false],

	[0xffffffff,0,false],
	[0xffffffff,1,false],
	[0xffffffff,0xffffffff,true],

	//0x00000001 00000001 = 4294967297
	[4294967297,0,false],
	[4294967297,1,false],
	[4294967297,4294967296,false],
	[4294967297,4294967297,true],

];
for(const [a,b,expect] of eqTest) {
	tsts(`u128{${a}}==u128{${b}}`,()=>{
		const a128=U128.fromInt(a);
		const b128=U128.fromInt(b);
		assert.is(a128.eq(b128),expect);
	})
    tsts(`u128{${a}}==u128{${b}}`,()=>{
		const a128=U128.fromInt(a);
		const b128=U128.fromInt(b);
		assert.is(a128.eq(b128),expect);
	})
}

const lastByteBETest:[number,number][]=[
	[0,0],
	[1,1],
	[0x1122,0x22],
];
for(const [a,expect] of lastByteBETest) {
	tsts(`lsb(${a})`,()=>{
		const a64=U128.fromInt(a);
		assert.is(a64.lsb(),expect);
	})
}

const lsbTest:[string,number,number][]=[
    ['000102030405060708090A0B0C0D0E0F',0,15],
    ['000102030405060708090A0B0C0D0E0F',1,14],
    ['000102030405060708090A0B0C0D0E0F',2,13],
    ['000102030405060708090A0B0C0D0E0F',3,12],
    ['000102030405060708090A0B0C0D0E0F',4,11],
    ['000102030405060708090A0B0C0D0E0F',5,10],
    ['000102030405060708090A0B0C0D0E0F',6,9],
    ['000102030405060708090A0B0C0D0E0F',7,8],
    ['000102030405060708090A0B0C0D0E0F',8,7],
    ['000102030405060708090A0B0C0D0E0F',9,6],
    ['000102030405060708090A0B0C0D0E0F',10,5],
    ['000102030405060708090A0B0C0D0E0F',11,4],
    ['000102030405060708090A0B0C0D0E0F',12,3],
    ['000102030405060708090A0B0C0D0E0F',13,2],
    ['000102030405060708090A0B0C0D0E0F',14,1],
    ['000102030405060708090A0B0C0D0E0F',15,0],
    ['000102030405060708090A0B0C0D0E0F',16,15],//Same as 0 because of &15
]
for(const [a,lsb,expect] of lsbTest){
	tsts(`lsb(${a},${lsb})`,()=>{
		const aBytes = hex.toBytes(a);
		const aUint = U128.fromBytesBE(aBytes);
		assert.is(aUint.lsb(lsb),expect);
	})
}

const lt64Test:[string,string][]=[
	['01020304050607080102030405060708','01020304050607080102030405060709'],
    ['01020304050607080102030405060708','01020304050607080102030405060808'],
    ['01020304050607080102030405060708','01020304050607080102030405070708'],
    ['01020304050607080102030405060708','01020304050607080102030406060708'], 
    ['01020304050607080102030405060708','01020304050607080102030505060708'], 
    ['01020304050607080102030405060708','01020304050607080102040405060708'], 
    ['01020304050607080102030405060708','01020304050607080103030405060708'], 
    ['01020304050607080102030405060708','01020304050607080202030405060708'],  
    ['01020304050607080102030405060708','01020304050607090102030405060708'],  
    ['01020304050607080102030405060708','01020304050608080102030405060708'],  
    ['01020304050607080102030405060708','01020304050707080102030405060708'],  
    ['01020304050607080102030405060708','01020304060607080102030405060708'],  
    ['01020304050607080102030405060708','01020305050607080102030405060708'],  
    ['01020304050607080102030405060708','01020404050607080102030405060708'],  
    ['01020304050607080102030405060708','01030304050607080102030405060708'],  
    ['01020304050607080102030405060708','02020304050607080102030405060708'],  
	['00000000000000000000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	['00000000000000000000000000000000','00000000000000000000000000000001'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
];
for (const [aHex,bHex] of lt64Test) {
	const aBytes=hex.toBytes(aHex);
	const bBytes=hex.toBytes(bHex);
	const a=U128.fromBytesBE(aBytes);
	const b=U128.fromBytesBE(bBytes);

	tsts(`${aHex} < ${bHex}`,()=>{
		assert.is(a.lt(b),true);
	});
	tsts(`! ${bHex} < ${aHex}`,()=>{
		assert.is(b.lt(a),false);
	});

	tsts(`${aHex} <= ${bHex}`,()=>{
		assert.is(a.lte(b),true);
	});
	tsts(`! ${bHex} < ${aHex}`,()=>{
		assert.is(b.lte(a),false);
	});

	tsts(`${bHex} > ${aHex}`,()=>{
		assert.is(b.gt(a),true);
	});
	tsts(`! ${aHex} > ${bHex}`,()=>{
		assert.is(a.gt(b),false);
	});

	tsts(`${bHex} >= ${aHex}`,()=>{
		assert.is(b.gte(a),true);
	});
	tsts(`! ${aHex} >= ${bHex}`,()=>{
		assert.is(a.gte(b),false);
	});
}


const eq64Test:string[]=[
	'0000000000000000',
	'0000000000000001',
	'0102030405060708',
	'0102030405060709',
	'FFFFFFFFFFFFFFF0',
	'FFFFFFFFFFFFFFFF'
];
for (const aHex of eq64Test) {
	const aBytes=hex.toBytes(aHex);
	const a=U128.fromBytesBE(aBytes);
	const b=U128.fromBytesBE(aBytes);

	tsts(`${aHex} == ${aHex}`,()=>{
		assert.is(a.eq(b),true);
	});

	tsts(`${aHex} <= ${aHex}`,()=>{
		assert.is(a.lte(b),true);
	});

	tsts(`! ${aHex} < ${aHex}`,()=>{
		assert.is(a.lt(b),false);
	});

	tsts(`${aHex} >= ${aHex}`,()=>{
		assert.is(b.gte(a),true);
	});

	tsts(`! ${aHex} > ${aHex}`,()=>{
		assert.is(b.gt(a),false);
	});


	//Constant time
	tsts(`${aHex} ==.ct ${aHex}`,()=>{
		assert.is(a.ctEq(b),true);
	});

	// tsts(`${aHex} <=.ct ${aHex}`,()=>{
	// 	assert.is(a.ctLte(b),true);
	// });

	// tsts(`! ${aHex} <.ct ${aHex}`,()=>{
	// 	assert.is(a.ctLt(b),false);
	// });
	
	// tsts(`${aHex} >=.ct ${aHex}`,()=>{
	// 	assert.is(a.ctGte(b),true);
	// });

	// tsts(`! ${aHex} >.ct ${aHex}`,()=>{
	// 	assert.is(a.ctGt(b),false);
	// });
}

// tsts(`ctSelect`,()=>{
// 	const aHex='0102030405060708';
// 	const bHex='F0E0D0C0B0A09080';
// 	const aBytes=hex.toBytes(aHex);
// 	const bBytes=hex.toBytes(bHex);
// 	const a=U128.fromBytesBE(aBytes);
// 	const b=U128.fromBytesBE(bBytes);

// 	assert.equal(U128.ctSelect(a,b,true).toBytesBE(),aBytes);
// 	assert.equal(U128.ctSelect(a,b,false).toBytesBE(),bBytes);
// })

// tsts(`ctSwitch`,()=>{
// 	const aHex='0102030405060708';
// 	const bHex='F0E0D0C0B0A09080';
// 	const aBytes=hex.toBytes(aHex);
// 	const bBytes=hex.toBytes(bHex);
// 	const a=U128.fromBytesBE(aBytes);
// 	const b=U128.fromBytesBE(bBytes);

// 	assert.equal(a.ctSwitch(b,true).toBytesBE(),bBytes);
// 	assert.equal(a.ctSwitch(b,false).toBytesBE(),aBytes);
// })

const toMinBytesTest:[string,Uint8Array,Uint8Array][]=[
	['00000000000000000000000000000000',Uint8Array.of(0),Uint8Array.of(0)],
	['00000000000000000000000000000001',Uint8Array.of(1),Uint8Array.of(1)],
	['00000000000000000000000000000010',Uint8Array.of(16),Uint8Array.of(16)],
	['00000000000000000000000000000100',Uint8Array.of(1,0),Uint8Array.of(0,1)],
	['00000000000000000000000000001000',Uint8Array.of(16,0),Uint8Array.of(0,16)],
	['00000000000000000000000000010000',Uint8Array.of(1,0,0),Uint8Array.of(0,0,1)],
	['00000000000000000000000000100000',Uint8Array.of(16,0,0),Uint8Array.of(0,0,16)],
	['00000000000000000000000001000000',Uint8Array.of(1,0,0,0),Uint8Array.of(0,0,0,1)],
	['00000000000000000000000010000000',Uint8Array.of(16,0,0,0),Uint8Array.of(0,0,0,16)],
	['00000000000000000000000100000000',Uint8Array.of(1,0,0,0,0),Uint8Array.of(0,0,0,0,1)],
	['00000000000000000000001000000000',Uint8Array.of(16,0,0,0,0),Uint8Array.of(0,0,0,0,16)],
	['00000000000000000000010000000000',Uint8Array.of(1,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,1)],
	['00000000000000000000100000000000',Uint8Array.of(16,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,16)],
	['00000000000000000001000000000000',Uint8Array.of(1,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,1)],
	['00000000000000000010000000000000',Uint8Array.of(16,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,16)],
	['00000000000000000100000000000000',Uint8Array.of(1,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,1)],
	['00000000000000001000000000000000',Uint8Array.of(16,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,16)],
	['00000000000000010000000000000000',Uint8Array.of(1,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,1)],
	['00000000000000100000000000000000',Uint8Array.of(16,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,16)],
	['00000000000001000000000000000000',Uint8Array.of(1,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,1)],
	['00000000000010000000000000000000',Uint8Array.of(16,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,16)],
	['00000000000100000000000000000000',Uint8Array.of(1,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,1)],
	['00000000001000000000000000000000',Uint8Array.of(16,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,16)],
	['00000000010000000000000000000000',Uint8Array.of(1,0,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,1)],
	['00000000100000000000000000000000',Uint8Array.of(16,0,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,16)],
	['00000001000000000000000000000000',Uint8Array.of(1,0,0,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,1)],
	['00000010000000000000000000000000',Uint8Array.of(16,0,0,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,16)],
	['00000100000000000000000000000000',Uint8Array.of(1,0,0,0,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,0,1)],
	['00001000000000000000000000000000',Uint8Array.of(16,0,0,0,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,0,16)],
	['00010000000000000000000000000000',Uint8Array.of(1,0,0,0,0,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,0,0,1)],
	['00100000000000000000000000000000',Uint8Array.of(16,0,0,0,0,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,0,0,16)],
	['01000000000000000000000000000000',Uint8Array.of(1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1)],
	['10000000000000000000000000000000',Uint8Array.of(16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,16)],
    ['00000000000000000102030405060708',Uint8Array.of(1,2,3,4,5,6,7,8),Uint8Array.of(8,7,6,5,4,3,2,1)],
    ['000102030405060708090A0B0C0D0E0F',Uint8Array.of(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15),Uint8Array.of(15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)],
    ['0102030405060708090A0B0C0D0E0F00',Uint8Array.of(1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,0),Uint8Array.of(0,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1)],
];
for(const [aHex,expectBE,expectLE] of toMinBytesTest) {
	const aBytes=hex.toBytes(aHex);
	const a=U128.fromBytesBE(aBytes);
	tsts(`U64(${aHex}).toMinBytesBE`,()=>{
		assert.equal(a.toMinBytesBE(),expectBE);
	});
	tsts(`U64(${aHex}).toMinBytesLE`,()=>{
		assert.equal(a.toMinBytesLE(),expectLE);
	});
}

const u64Tests:[string,string,string][]=[
    ['0102030405060708','0000000000000000','00000000000000000102030405060708'],
    ['0000000000000001','0000000000000002','00000000000000020000000000000001']
];
for(const [aHex,bHex,uHex] of u64Tests) {
    const a=U64.fromBytesBE(hex.toBytes(aHex));
    const b=U64.fromBytesBE(hex.toBytes(bHex));
    const u=U128.fromU64Pair(a,b);
    tsts(`U128.fromU64Pair(${aHex},${bHex})`,()=>{
        assert.equal(hex.fromBytes(u.toBytesBE()),uHex);
	});
    tsts(`U128.mut64(${uHex})`,()=>{
        const a64=u.mut64();
        assert.equal(hex.fromBytes(a64.at(0).toBytesBE()),aHex);
        assert.equal(hex.fromBytes(a64.at(1).toBytesBE()),bHex);
	});
}

tsts('fromBytesLE',()=>{
	const aBytes=hex.toBytes('01000000000000000000000000000000');
	const a=U128.fromBytesLE(aBytes);
	assert.equal(a.toMinBytesLE(),Uint8Array.of(1));
});

tsts(`clone`,()=>{
	//Really just for coverage (since you cannot mutate, what's the value of a clone?)
	const a=U128.fromInt(1).clone();
	assert.equal(a.eq(U128.fromInt(1)),true);
});

tsts(`mut`,()=>{
	const a=U128.fromUint32Quad(1,2,3,4);
	const b=a.mut().add(a);
	assert.equal(b.eq(U128.fromUint32Quad(2,4,6,8)),true,'b changed');
	assert.equal(a.eq(U128.fromUint32Quad(1,2,3,4)),true,'a the same');
});

tsts(`mut32`,()=>{
	const a=U128.fromUint32Quad(1,2,3,4);
	const b=a.mut32();
    b[0]=4;b[1]=3;b[2]=2;b[3]=1;
	assert.equal(a.eq(U128.fromUint32Quad(1,2,3,4)),true,'a the same');
});

tsts(`mut64`,()=>{
	const a=U128.fromUint32Quad(1,2,3,4);
	const b=a.mut64();
    b.at(0).set(U64.fromUint32Pair(9,8));
	assert.equal(a.eq(U128.fromUint32Quad(1,2,3,4)),true,'a the same');
});

const fromIntTests:[number,string][]=[
    [1,'00000000000000000000000000000001'],
    [0x12345678,'00000000000000000000000012345678'],
];
for(const[int,expect] of fromIntTests) {
    tsts(`fromIntUnsafe(${int})`,()=>{
        const u=U128.fromIntUnsafe(int);
        assert.is(u.toString(),expect);
	});
    tsts(`fromInt(${int})`,()=>{
        const u=U128.fromInt(int);
        assert.is(u.toString(),expect);
	});
}

tsts(`fromArray`,()=>{
	const a=U128.fromArray(Uint32Array.of(1,0,0,0));
	assert.equal(a.eq(U128.fromInt(1)),true);
});

tsts(`fromBuffer`,()=>{
	const a=U128.fromBuffer(Uint32Array.of(1,0,0,0).buffer);
	assert.equal(a.eq(U128.fromInt(1)),true);
});

tsts(`constants`,()=>{
	assert.equal(U128.max.toBytesBE(),Uint8Array.of(0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff));
	assert.equal(U128.min.toBytesBE(),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0));
	assert.equal(U128.zero.toBytesBE(),Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0));
});

tsts('[Symbol.toStringTag]', () => {
    const o=U128.fromInt(1);
	const str = Object.prototype.toString.call(o);
	assert.is(str.indexOf('U128') > 0, true);
});

tsts('util.inspect',()=>{
    const o=U128.fromInt(1);
    const u=util.inspect(o);
    assert.is(u.startsWith('U128('),true);
});

tsts('coverage',()=>{
    const a=U128.fromArray(Uint32Array.of(1,2,3,4));//Low -> high bytes
    assert.equal(a.toString(),'00000004000000030000000200000001');
    assert.equal(a.lowLow,1);
    assert.equal(a.lowHigh,2);
    assert.equal(a.highLow,3);
    assert.equal(a.highHigh,4);
})

tsts.run();
