import { suite } from 'uvu';
import * as assert from 'uvu/assert';
import { hex } from '../../../src/codec';
import { U128 } from '../../../src/primitive/number/U128';
import util from 'util';

//There's extra tests in here since U128 is big enough for AInt testing

const tsts = suite('U128');

const h0 = '00000000000000000000000000000000';
const h1 = '00000000000000000000000000000001';
const hMax = 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF';
const hNum = '0102030405060708090A0B0C0D0E0F11';
// - binary -
// 0000000100000010000000110000010000000101000001100000011100001000
// 0000100100001010000010110000110000001101000011100000111100010001
// - decimal -
// 1339673755198158349044581307228491537
const hNNum = 'FEFDFCFBFAF9F8F7F6F5F4F3F2F1F0EE';
const hexBuild = (h: string) => U128.fromBytesBE(hex.toBytes(h));

const toString_tests = [
	h0,
	h1,
	'10000000000000000000000000000000',
	'FEDCBA98765432100000000000000000',
	'00000000000000000FEDCBA987654321',
	'C4D5E6F78091A2B30000000000000000',
	'0000000000000000C4D5E6F78091A2B3',
	hNum,
];
for (const expect of toString_tests) {
	tsts(`${expect}.toString`, () => {
		const u = hexBuild(expect);
		assert.is(u.toString(), expect);
	});
}

const u32le_hex_tests: [number[], string][] = [
	[[1, 2, 3, 4], '00000004000000030000000200000001'],
];
for (const [u32s, expect] of u32le_hex_tests) {
	const fromUints = U128.fromI32s(...u32s);
	tsts(`fromUints(${u32s})`, () => {
		assert.is(fromUints.toString(), expect);
	});

	const fromBytesBE = hexBuild(expect);
	tsts(`fromBytesBE(${expect})`, () => {
		assert.is(fromBytesBE.toString(), expect);
	});

	tsts(`mount(${expect})`, () => {
		const arr = Uint32Array.from(u32s);
		const u = U128.mount(arr);
		assert.is(u.toString(), expect);
	});
}

const fromInt_tests: [number, string][] = [
	[1, h1],
	[0x12345678, '00000000000000000000000012345678'],
];
for (const [int, expect] of fromInt_tests) {
	tsts(`fromInt(${int})`, () => {
		const u = U128.fromInt(int);
		assert.is(u.toString(), expect);
	});
}

// prettier-ignore
const u8le_hex_tests:[Uint8Array,string][]=[
    [Uint8Array.of(15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0),'000102030405060708090A0B0C0D0E0F'],
    [Uint8Array.of(1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0),'00000000000000000000000000000001'],
    [Uint8Array.of(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1),'01000000000000000000000000000000'],
];
for (const [bytesLE, expect] of u8le_hex_tests) {
	tsts(`fromBytesLE(${expect})`, () => {
		const u = U128.fromBytesLE(bytesLE);
		assert.is(u.toString(), expect);
	});
}

//#region ShiftOps
// prettier-ignore
const lShift_tests: [string, number, string][] = [
    [h0, 0, h0],
    [h0, 1, h0],
    [h0, 13, h0],
    [h0, 32, h0],

    [hMax, 0, hMax],
    [hMax, 1, 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE'],
    [hMax, 13, 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFE000'],
    [hMax, 32, 'FFFFFFFFFFFFFFFFFFFFFFFF00000000'],
    [hMax, 64, 'FFFFFFFFFFFFFFFF0000000000000000'],

    [hNum, 0, hNum],
    [hNum, 1, '020406080A0C0E10121416181A1C1E22'],
    [hNum, 2, '04080C1014181C2024282C3034383C44'],
    [hNum, 16, '030405060708090A0B0C0D0E0F110000'],
    [hNum, 32, '05060708090A0B0C0D0E0F1100000000'],
    [hNum, 65, '121416181A1C1E220000000000000000'],
    [hNum, 120, '11000000000000000000000000000000'],
    //Can exceed size
    [hNum, 600, h0],

    ['FEDCBA9876543210FEDCBA9876543210', 0, 'FEDCBA9876543210FEDCBA9876543210'],
	['FEDCBA9876543210FEDCBA9876543210', 1, 'FDB97530ECA86421FDB97530ECA86420'],
	['FEDCBA9876543210FEDCBA9876543210', 4, 'EDCBA9876543210FEDCBA98765432100'],
	['FEDCBA9876543210FEDCBA9876543210', 8, 'DCBA9876543210FEDCBA987654321000'],
	['FEDCBA9876543210FEDCBA9876543210', 16, 'BA9876543210FEDCBA98765432100000'],
	['FEDCBA9876543210FEDCBA9876543210', 24, '9876543210FEDCBA9876543210000000'],
	['FEDCBA9876543210FEDCBA9876543210', 28, '876543210FEDCBA98765432100000000'],
	['FEDCBA9876543210FEDCBA9876543210', 31, '3B2A19087F6E5D4C3B2A190800000000'],
	['FEDCBA9876543210FEDCBA9876543210', 32, '76543210FEDCBA987654321000000000'],
	['FEDCBA9876543210FEDCBA9876543210', 33, 'ECA86421FDB97530ECA8642000000000'],
	['FEDCBA9876543210FEDCBA9876543210', 36, '6543210FEDCBA9876543210000000000'],
	['FEDCBA9876543210FEDCBA9876543210', 48, '3210FEDCBA9876543210000000000000'],
	['FEDCBA9876543210FEDCBA9876543210', 63, '7F6E5D4C3B2A19080000000000000000'],
	['FEDCBA9876543210FEDCBA9876543210', 64, 'FEDCBA98765432100000000000000000'],
    ['FEDCBA9876543210FEDCBA9876543210', 128, '00000000000000000000000000000000'],
];
for (const [start, by, expect] of lShift_tests) {
	tsts(`${start} << ${by}`, () => {
		const a = hexBuild(start);
		const b = a.lShift(by);
		assert.is(hex.fromBytes(b.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), start, 'No mutation');
	});
}
// prettier-ignore
const rShift_tests: [string, number, string][] = [
    [h0, 0, h0],
    [h0, 1, h0],
    [h0, 13, h0],
    [h0, 32, h0],

    [hMax, 0, hMax],
    [hMax, 1, '7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    [hMax, 13, '0007FFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    [hMax, 32, '00000000FFFFFFFFFFFFFFFFFFFFFFFF'],
    [hMax, 64, '0000000000000000FFFFFFFFFFFFFFFF'],

    [hNum, 0, hNum],
    [hNum, 1, '00810182028303840485058606870788'],
    [hNum, 2, '004080C1014181C2024282C3034383C4'],
    [hNum, 16, '00000102030405060708090A0B0C0D0E'],
    [hNum, 32, '000000000102030405060708090A0B0C'],
    [hNum, 65, '00000000000000000081018202830384'],
    [hNum, 120, '00000000000000000000000000000001'],
    //Can exceed size
    [hNum, 600, h0],

    ['0123456789ABCDEFFEDCBA9876543210', 0, '0123456789ABCDEFFEDCBA9876543210'],
	['0123456789ABCDEFFEDCBA9876543210', 1, '0091A2B3C4D5E6F7FF6E5D4C3B2A1908'],
	['0123456789ABCDEFFEDCBA9876543210', 4, '00123456789ABCDEFFEDCBA987654321'],
	['0123456789ABCDEFFEDCBA9876543210', 8, '000123456789ABCDEFFEDCBA98765432'],
	['0123456789ABCDEFFEDCBA9876543210', 16, '00000123456789ABCDEFFEDCBA987654'],
	['0123456789ABCDEFFEDCBA9876543210', 24, '0000000123456789ABCDEFFEDCBA9876'],
	['0123456789ABCDEFFEDCBA9876543210', 28, '00000000123456789ABCDEFFEDCBA987'],
	['0123456789ABCDEFFEDCBA9876543210', 31, '0000000002468ACF13579BDFFDB97530'],
	['0123456789ABCDEFFEDCBA9876543210', 32, '000000000123456789ABCDEFFEDCBA98'],
	['0123456789ABCDEFFEDCBA9876543210', 33, '000000000091A2B3C4D5E6F7FF6E5D4C'],
	['0123456789ABCDEFFEDCBA9876543210', 36, '0000000000123456789ABCDEFFEDCBA9'],
	['0123456789ABCDEFFEDCBA9876543210', 48, '0000000000000123456789ABCDEFFEDC'],
	['0123456789ABCDEFFEDCBA9876543210', 63, '000000000000000002468ACF13579BDF'],
	['0123456789ABCDEFFEDCBA9876543210', 64, '00000000000000000123456789ABCDEF'],

	['0123456789ABCDEF0123456789ABCDEF', 0, '0123456789ABCDEF0123456789ABCDEF'],
	['0123456789ABCDEF0123456789ABCDEF', 1, '0091A2B3C4D5E6F78091A2B3C4D5E6F7'],
	['0123456789ABCDEF0123456789ABCDEF', 4, '00123456789ABCDEF0123456789ABCDE'],
	['0123456789ABCDEF0123456789ABCDEF', 8, '000123456789ABCDEF0123456789ABCD'],
	['0123456789ABCDEF0123456789ABCDEF', 16, '00000123456789ABCDEF0123456789AB'],
	['0123456789ABCDEF0123456789ABCDEF', 24, '0000000123456789ABCDEF0123456789'],
	['0123456789ABCDEF0123456789ABCDEF', 28, '00000000123456789ABCDEF012345678'],
	['0123456789ABCDEF0123456789ABCDEF', 31, '0000000002468ACF13579BDE02468ACF'],
	['0123456789ABCDEF0123456789ABCDEF', 32, '000000000123456789ABCDEF01234567'],
	['0123456789ABCDEF0123456789ABCDEF', 33, '000000000091A2B3C4D5E6F78091A2B3'],
	['0123456789ABCDEF0123456789ABCDEF', 48, '0000000000000123456789ABCDEF0123'],
	['0123456789ABCDEF0123456789ABCDEF', 63, '000000000000000002468ACF13579BDE'],
	['0123456789ABCDEF0123456789ABCDEF', 64, '00000000000000000123456789ABCDEF'],
    ['0123456789ABCDEF0123456789ABCDEF', 128, '00000000000000000000000000000000'],
];
for (const [start, by, expect] of rShift_tests) {
	tsts(`${start} >> ${by}`, () => {
		const a = hexBuild(start);
		const b = a.rShift(by);
		assert.is(hex.fromBytes(b.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), start, 'No mutation');
	});
}
//https://onlinetools.com/binary/rotate-binary-bits
//https://www.rapidtables.com/convert/number/binary-to-hex.html
// prettier-ignore
const lRot_tests: [string, number, string][] = [
    [hNum, 0, hNum],
    [hNum, 1, '020406080A0C0E10121416181A1C1E22'],
    [hNum, 2, '04080C1014181C2024282C3034383C44'],
    [hNum, 16, '030405060708090A0B0C0D0E0F110102'],
    [hNum, 32, '05060708090A0B0C0D0E0F1101020304'],
    [hNum, 65, '121416181A1C1E22020406080A0C0E10'],
    [hNum, 120, '110102030405060708090A0B0C0D0E0F'],
    //Can exceed size
    [hNum, 600, '0C0D0E0F110102030405060708090A0B'],
    ['FEDCBA9876543210FEDCBA9876543210', 0, 'FEDCBA9876543210FEDCBA9876543210'],
	['FEDCBA9876543210FEDCBA9876543210', 1, 'FDB97530ECA86421FDB97530ECA86421'],
	['FEDCBA9876543210FEDCBA9876543210', 4, 'EDCBA9876543210FEDCBA9876543210F'],
	['FEDCBA9876543210FEDCBA9876543210', 8, 'DCBA9876543210FEDCBA9876543210FE'],
	['FEDCBA9876543210FEDCBA9876543210', 12, 'CBA9876543210FEDCBA9876543210FED'],
	['FEDCBA9876543210FEDCBA9876543210', 16, 'BA9876543210FEDCBA9876543210FEDC'],
	['FEDCBA9876543210FEDCBA9876543210', 20, 'A9876543210FEDCBA9876543210FEDCB'],
	['FEDCBA9876543210FEDCBA9876543210', 24, '9876543210FEDCBA9876543210FEDCBA'],
	['FEDCBA9876543210FEDCBA9876543210', 28, '876543210FEDCBA9876543210FEDCBA9'],
	['FEDCBA9876543210FEDCBA9876543210', 31, '3B2A19087F6E5D4C3B2A19087F6E5D4C'],
	['FEDCBA9876543210FEDCBA9876543210', 32, '76543210FEDCBA9876543210FEDCBA98'],
	['FEDCBA9876543210FEDCBA9876543210', 33, 'ECA86421FDB97530ECA86421FDB97530'],
	['FEDCBA9876543210FEDCBA9876543210', 36, '6543210FEDCBA9876543210FEDCBA987'],
	['FEDCBA9876543210FEDCBA9876543210', 40, '543210FEDCBA9876543210FEDCBA9876'],
	['FEDCBA9876543210FEDCBA9876543210', 44, '43210FEDCBA9876543210FEDCBA98765'],
	['FEDCBA9876543210FEDCBA9876543210', 48, '3210FEDCBA9876543210FEDCBA987654'],
	['FEDCBA9876543210FEDCBA9876543210', 52, '210FEDCBA9876543210FEDCBA9876543'],
	['FEDCBA9876543210FEDCBA9876543210', 56, '10FEDCBA9876543210FEDCBA98765432'],
	['FEDCBA9876543210FEDCBA9876543210', 60, '0FEDCBA9876543210FEDCBA987654321'],
	['FEDCBA9876543210FEDCBA9876543210', 63, '7F6E5D4C3B2A19087F6E5D4C3B2A1908'],
	['FEDCBA9876543210FEDCBA9876543210', 64, 'FEDCBA9876543210FEDCBA9876543210'],
    ['FEDCBA9876543210FEDCBA9876543210', 128, 'FEDCBA9876543210FEDCBA9876543210'],

	['0123456789ABCDEF0123456789ABCDEF', 0, '0123456789ABCDEF0123456789ABCDEF'],
	['0123456789ABCDEF0123456789ABCDEF', 1, '02468ACF13579BDE02468ACF13579BDE'],
	['0123456789ABCDEF0123456789ABCDEF', 4, '123456789ABCDEF0123456789ABCDEF0'],
	['0123456789ABCDEF0123456789ABCDEF', 8, '23456789ABCDEF0123456789ABCDEF01'],
	['0123456789ABCDEF0123456789ABCDEF', 12, '3456789ABCDEF0123456789ABCDEF012'],
	['0123456789ABCDEF0123456789ABCDEF', 16, '456789ABCDEF0123456789ABCDEF0123'],
	['0123456789ABCDEF0123456789ABCDEF', 20, '56789ABCDEF0123456789ABCDEF01234'],
	['0123456789ABCDEF0123456789ABCDEF', 24, '6789ABCDEF0123456789ABCDEF012345'],
	['0123456789ABCDEF0123456789ABCDEF', 28, '789ABCDEF0123456789ABCDEF0123456'],
	['0123456789ABCDEF0123456789ABCDEF', 31, 'C4D5E6F78091A2B3C4D5E6F78091A2B3'],
	['0123456789ABCDEF0123456789ABCDEF', 32, '89ABCDEF0123456789ABCDEF01234567'],
	['0123456789ABCDEF0123456789ABCDEF', 33, '13579BDE02468ACF13579BDE02468ACF'],
	['0123456789ABCDEF0123456789ABCDEF', 36, '9ABCDEF0123456789ABCDEF012345678'],
	['0123456789ABCDEF0123456789ABCDEF', 40, 'ABCDEF0123456789ABCDEF0123456789'],
	['0123456789ABCDEF0123456789ABCDEF', 44, 'BCDEF0123456789ABCDEF0123456789A'],
	['0123456789ABCDEF0123456789ABCDEF', 48, 'CDEF0123456789ABCDEF0123456789AB'],
	['0123456789ABCDEF0123456789ABCDEF', 52, 'DEF0123456789ABCDEF0123456789ABC'],
	['0123456789ABCDEF0123456789ABCDEF', 56, 'EF0123456789ABCDEF0123456789ABCD'],
	['0123456789ABCDEF0123456789ABCDEF', 60, 'F0123456789ABCDEF0123456789ABCDE'],
	['0123456789ABCDEF0123456789ABCDEF', 63, '8091A2B3C4D5E6F78091A2B3C4D5E6F7'],
	['0123456789ABCDEF0123456789ABCDEF', 64, '0123456789ABCDEF0123456789ABCDEF'],
    ['0123456789ABCDEF0123456789ABCDEF', 127, '8091A2B3C4D5E6F78091A2B3C4D5E6F7'],
    ['0123456789ABCDEF0123456789ABCDEF', 128, '0123456789ABCDEF0123456789ABCDEF'],
];
for (const [start, by, expect] of lRot_tests) {
	tsts(`${start} ROL ${by}`, () => {
		const a = hexBuild(start);
		const b = a.lRot(by);
		assert.is(hex.fromBytes(b.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), start, 'No mutation');
	});
}
//Note these are the same as lRot(256-#)
// prettier-ignore
const rRot_tests: [string, number, string][] = [
    [hNum, 0, hNum],
    [hNum, 1, '80810182028303840485058606870788'],
    ['0123456789ABCDEFFEDCBA9876543210', 0, '0123456789ABCDEFFEDCBA9876543210'],
	['0123456789ABCDEFFEDCBA9876543210', 1, '0091A2B3C4D5E6F7FF6E5D4C3B2A1908'],
	['0123456789ABCDEFFEDCBA9876543210', 4, '00123456789ABCDEFFEDCBA987654321'],
	['0123456789ABCDEFFEDCBA9876543210', 8, '100123456789ABCDEFFEDCBA98765432'],
	['0123456789ABCDEFFEDCBA9876543210', 12, '2100123456789ABCDEFFEDCBA9876543'],
	['0123456789ABCDEFFEDCBA9876543210', 16, '32100123456789ABCDEFFEDCBA987654'],
	['0123456789ABCDEFFEDCBA9876543210', 20, '432100123456789ABCDEFFEDCBA98765'],
	['0123456789ABCDEFFEDCBA9876543210', 24, '5432100123456789ABCDEFFEDCBA9876'],
	['0123456789ABCDEFFEDCBA9876543210', 28, '65432100123456789ABCDEFFEDCBA987'],
	['0123456789ABCDEFFEDCBA9876543210', 31, 'ECA8642002468ACF13579BDFFDB97530'],
	['0123456789ABCDEFFEDCBA9876543210', 32, '765432100123456789ABCDEFFEDCBA98'],
	['0123456789ABCDEFFEDCBA9876543210', 33, '3B2A19080091A2B3C4D5E6F7FF6E5D4C'],
	['0123456789ABCDEFFEDCBA9876543210', 36, '8765432100123456789ABCDEFFEDCBA9'],
	['0123456789ABCDEFFEDCBA9876543210', 40, '98765432100123456789ABCDEFFEDCBA'],
	['0123456789ABCDEFFEDCBA9876543210', 44, 'A98765432100123456789ABCDEFFEDCB'],
	['0123456789ABCDEFFEDCBA9876543210', 48, 'BA98765432100123456789ABCDEFFEDC'],
	['0123456789ABCDEFFEDCBA9876543210', 52, 'CBA98765432100123456789ABCDEFFED'],
	['0123456789ABCDEFFEDCBA9876543210', 56, 'DCBA98765432100123456789ABCDEFFE'],
	['0123456789ABCDEFFEDCBA9876543210', 60, 'EDCBA98765432100123456789ABCDEFF'],
	['0123456789ABCDEFFEDCBA9876543210', 63, 'FDB97530ECA8642002468ACF13579BDF'],
	['0123456789ABCDEFFEDCBA9876543210', 64, 'FEDCBA98765432100123456789ABCDEF'],
    ['0123456789ABCDEFFEDCBA9876543210', 127, '02468ACF13579BDFFDB97530ECA86420'],
    ['0123456789ABCDEFFEDCBA9876543210', 128, '0123456789ABCDEFFEDCBA9876543210'],
	//We can exceed
    ['0123456789ABCDEFFEDCBA9876543210', 129, '0091A2B3C4D5E6F7FF6E5D4C3B2A1908'],//=1
    ['0123456789ABCDEFFEDCBA9876543210', -1, '02468ACF13579BDFFDB97530ECA86420'],//=127
];
for (const [start, by, expect] of rRot_tests) {
	tsts(`${start} ROR ${by}`, () => {
		const a = hexBuild(start);
		const b = a.rRot(by);
		assert.is(hex.fromBytes(b.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), start, 'No mutation');
	});
}
//#endregion

//#region LogicOps
// prettier-ignore
const xor_tests = [
	// A^0=A: Anything xor zero is anything
	[h0, hNum, hNum],
	// A^1=~A:  Anything XOR 1 is its compliment
	[hMax, hNum, hNNum],
	// A^~A=1 Anything xor its compliment is 1
	[hNum, hNNum, hMax],
	// A^A=A Anything xor itself is 0
	[hNum, hNum, h0],
	// Other cases
	['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000003'],
	['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE'],
];
for (const [aHex, bHex, expect] of xor_tests) {
	tsts(`${aHex} ^ ${bHex}`, () => {
		const a = hexBuild(aHex);
		const b = hexBuild(bHex);
		const res = a.xor(b);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), aHex, 'No mutation');
	});
}

// prettier-ignore
const or_tests = [
	// A|0=A: Anything or zero is anything
	[hNum, h0, hNum],
	// A|1=1:  Anything or 1 is 1
	[hNum, hMax, hMax],
	// A|~A=1: Anything or its compliment is 1
	[hNum, hNNum, hMax],
	// A|A=A: Anything or itself is itself
	[hNum, hNum, hNum],
	// Any bits set override the other value (form of masking)
	['FEDCBA9876543210FEDCBA9876543210','0000000000000000FFFFFFFFFFFFFFFF','FEDCBA9876543210FFFFFFFFFFFFFFFF'],
	['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','0000000000000000FFFFFFFFFFFFFFFF','C3A5A5A5A5A5A5A5FFFFFFFFFFFFFFFF'],
	['FEDCBA9876543210FEDCBA9876543210','FFFFFFFFFFFFFFFF0000000000000000','FFFFFFFFFFFFFFFFFEDCBA9876543210'],
	['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','FFFFFFFFFFFFFFFF0000000000000000','FFFFFFFFFFFFFFFFA5A5A5A5A5A5A53C'],

	['00000000000000010000000000000001','00000000000000000000000000000002','00000000000000010000000000000003'],
	['00000000000000010000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
];
for (const [aHex, bHex, expect] of or_tests) {
	tsts(`${aHex} | ${bHex}`, () => {
		const a = hexBuild(aHex);
		const b = hexBuild(bHex);
		const res = a.or(b);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), aHex, 'No mutation');
	});
}

// prettier-ignore
const and_tests = [
	// A&0=0: Zero and anything is zero
	[h0, hNum, h0],
	// A&1=A:  All set and anything is anything
	[hMax, hNum, hNum],
	// A&~A=0: Anything and its compliment is 0
	[hNum, hNNum, h0],
	// A&A=A: Anything and itself is itself
	[hNum, hNum, hNum],
	// Only bits set to true in both survive (form of masking)
	['FEDCBA9876543210FEDCBA9876543210','00000000000000000000000FFFFFFFFF','00000000000000000000000876543210'],
	['FEDCBA9876543210FEDCBA9876543210','FFFFFFFFF00000000000000000000000','FEDCBA98700000000000000000000000'],
	['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','0000000000000000FFFFFFFFFFFFFFFF','0000000000000000A5A5A5A5A5A5A53C'],
	['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','FFFFFFFFFFFFFFFF0000000000000000','C3A5A5A5A5A5A5A50000000000000000'],
	['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000000'],
	['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000001'],
];
for (const [aHex, bHex, expect] of and_tests) {
	tsts(`${aHex} & ${bHex}`, () => {
		const a = hexBuild(aHex);
		const b = hexBuild(bHex);
		const res = a.and(b);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), aHex, 'No mutation');
	});
}

const not_tests = [
	[h0, hMax],
	[hNum, hNNum],
	['00000000000000000000000000000001', 'FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFE'],
	['10000000000000000000000000000000', 'EFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	['00000000FFFFFFFF00000000FFFFFFFF', 'FFFFFFFF00000000FFFFFFFF00000000'],
	['0000000000000000FFFFFFFFFFFFFFFF', 'FFFFFFFFFFFFFFFF0000000000000000'],
	['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C', '3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3'], //A=1010, 5=0101, C=1100, 3=0011
	['FEDCBA9876543210FEDCBA9876543210', '0123456789ABCDEF0123456789ABCDEF'],
];
for (const [start, expect] of not_tests) {
	tsts(`~${start}`, () => {
		const a = hexBuild(start);
		const res = a.not();
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), start, 'No mutation');
	});
}
//#endregion

//#region Arithmetic

// prettier-ignore
const add_tests=[
    // A+0=A: Anything plus zero is anything (like or)
    [hNum,h0,hNum],
    [hMax,h1,h0],
    [hMax,hNum,'0102030405060708090A0B0C0D0E0F10'],//Ends up being the same as -1 because of wrap
    // A+~A .. is 1 (like or)
    ['0000000000000000FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFF0000000000000000','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','3C5A5A5A5A5A5A5A5A5A5A5A5A5A5AC3','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','3CA5A5A5A5A5A5A5A5A5A5A5A5A5A5C3','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    ['FEDCBA98765432100123456789ABCDEF','0123456789ABCDEFFEDCBA9876543210','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
    // A+A=2A
    ['0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF','0000000000000001FFFFFFFFFFFFFFFE'],
    ['C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','C3A5A5A5A5A5A5A5A5A5A5A5A5A5A53C','874B4B4B4B4B4B4B4B4B4B4B4B4B4A78'],//Overflow
    ['C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','C35A5A5A5A5A5A5A5A5A5A5A5A5A5A3C','86B4B4B4B4B4B4B4B4B4B4B4B4B4B478'],//Overflow
    ['FEDCBA9876543210FEDCBA9876543210','FEDCBA9876543210FEDCBA9876543210','FDB97530ECA86421FDB97530ECA86420'],//Overflow
    // // Others
    ['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000003'],
    ['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000000'],//Overflow

];
for (const [aHex, bHex, expect] of add_tests) {
	tsts(`${aHex} + ${bHex}`, () => {
		const a = hexBuild(aHex);
		const b = hexBuild(bHex);
		const res = a.add(b);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), aHex, 'No mutation-a');
		assert.is(hex.fromBytes(b.toBytesBE()), bHex, 'No mutation-b');
	});
}

// prettier-ignore
const sub_tests:[string,string,string][]=[
    [h1,h1,h0],
    [h0,h1,hMax],
    [hNum,h1,'0102030405060708090A0B0C0D0E0F10'],
];
for (const [aHex, bHex, expect] of sub_tests) {
	tsts(`${aHex} - ${bHex}`, () => {
		const a = hexBuild(aHex);
		const b = hexBuild(bHex);
		const res = a.sub(b);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), aHex, 'No mutation-a');
		assert.is(hex.fromBytes(b.toBytesBE()), bHex, 'No mutation-b');
	});
}

// prettier-ignore
const mul_tests:[string,string,string][]=[
    //https://www.dcode.fr/big-numbers-multiplication
    [h0,hNum,h0],
    [h1,hNum,hNum],
    [hNum,hNum,'35AF166AAAD5EAE8CE9B4DE560BEFF21'],
    //full result: 1040A1423385478A5DD1F6DC932AB35AF166AAAD5EAE8CE9B4DE560BEFF21
	['00000000000000000000000000000001','00000000000000000000000000000002','00000000000000000000000000000002'],
    ['0000000000000000000000000000000F','0000000000000000000000000000000F','000000000000000000000000000000E1'],
    ['000000000000000000000000000000FF','000000000000000000000000000000FF','0000000000000000000000000000FE01'],
    ['00000000000000000000000000000FFF','00000000000000000000000000000FFF','00000000000000000000000000FFE001'],
	['0000000000000000000000000000FFFF','0000000000000000000000000000FFFF','000000000000000000000000FFFE0001'],
	['000000000000000000000000000FFFFF','000000000000000000000000000FFFFF','0000000000000000000000FFFFE00001'],
	['00000000000000000000000000FFFFFF','00000000000000000000000000FFFFFF','00000000000000000000FFFFFE000001'],
	['0000000000000000000000000FFFFFFF','0000000000000000000000000FFFFFFF','000000000000000000FFFFFFE0000001'],//0000000000000000
	['000000000000000000000000FFFFFFFF','000000000000000000000000FFFFFFFF','0000000000000000FFFFFFFE00000001'],
	['00000000000000000000000FFFFFFFFF','00000000000000000000000FFFFFFFFF','00000000000000FFFFFFFFE000000001'],
	['0000000000000000000000FFFFFFFFFF','0000000000000000000000FFFFFFFFFF','000000000000FFFFFFFFFE0000000001'],
	['000000000000000000000FFFFFFFFFFF','000000000000000000000FFFFFFFFFFF','0000000000FFFFFFFFFFE00000000001'],
	['00000000000000000000FFFFFFFFFFFF','00000000000000000000FFFFFFFFFFFF','00000000FFFFFFFFFFFE000000000001'],
	['0000000000000000000FFFFFFFFFFFFF','0000000000000000000FFFFFFFFFFFFF','000000FFFFFFFFFFFFE0000000000001'],
	['000000000000000000FFFFFFFFFFFFFF','000000000000000000FFFFFFFFFFFFFF','0000FFFFFFFFFFFFFE00000000000001'],
	['00000000000000000FFFFFFFFFFFFFFF','00000000000000000FFFFFFFFFFFFFFF','00FFFFFFFFFFFFFFE000000000000001'],
    ['0000000000000000FFFFFFFFFFFFFFFF','0000000000000000FFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFE0000000000000001'],
    ['000000000000000FFFFFFFFFFFFFFFFF','000000000000000FFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFE00000000000000001'],
    ['00000000000000FFFFFFFFFFFFFFFFFF','00000000000000FFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFE000000000000000001'],
    ['0000000000000FFFFFFFFFFFFFFFFFFF','0000000000000FFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFE0000000000000000001'],
    ['000000000000FFFFFFFFFFFFFFFFFFFF','000000000000FFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFE00000000000000000001'],
    ['00000000000FFFFFFFFFFFFFFFFFFFFF','00000000000FFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFE000000000000000000001'],
    ['0000000000FFFFFFFFFFFFFFFFFFFFFF','0000000000FFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFE0000000000000000000001'],
    ['000000000FFFFFFFFFFFFFFFFFFFFFFF','000000000FFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFE00000000000000000000001'],
    ['00000000FFFFFFFFFFFFFFFFFFFFFFFF','00000000FFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFE000000000000000000000001'],
    ['0000000FFFFFFFFFFFFFFFFFFFFFFFFF','0000000FFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFE0000000000000000000000001'],
    ['000000FFFFFFFFFFFFFFFFFFFFFFFFFF','000000FFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFE00000000000000000000000001'],
    ['00000FFFFFFFFFFFFFFFFFFFFFFFFFFF','00000FFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFE000000000000000000000000001'],
    ['0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF','0000FFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFE0000000000000000000000000001'],
    ['000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF','000FFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFE00000000000000000000000000001'],
    ['00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FE000000000000000000000000000001'],
    ['0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','0FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','E0000000000000000000000000000001'],
	['FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000001'],
	['00000000000000000000000000000001','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF'],
	['7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF','00000000000000000000000000000010','FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF0'],//Prove it is unsigned    
];
for (const [aHex, bHex, expect] of mul_tests) {
	tsts(`${aHex} * ${bHex}`, () => {
		const a = hexBuild(aHex);
		const b = hexBuild(bHex);
		const res = a.mul(b);
		assert.is(hex.fromBytes(res.toBytesBE()), expect);
		assert.is(hex.fromBytes(a.toBytesBE()), aHex, 'No mutation-a');
		assert.is(hex.fromBytes(b.toBytesBE()), bHex, 'No mutation-b');
	});
}
//#endregion

//#region Comparable
const neq_tests: [string, string][] = [
	[h0, h1],
	[hNum, h0],
	[hNum, h1],
	[hNum, hMax],
];
for (const [aHex, bHex] of neq_tests) {
	const a = hexBuild(aHex);
	const b = hexBuild(bHex);
	tsts(`${aHex} != ${bHex}`, () => {
		assert.is(a.eq(b), false);
	});
	tsts(`${bHex} != ${aHex}`, () => {
		assert.is(b.eq(a), false);
	});
}

const eq_set: string[] = [h0, h1, hNum, hMax];
for (const aHex of eq_set) {
	const bHex = aHex;
	const a = hexBuild(aHex);
	const b = hexBuild(bHex);
	tsts(`${aHex} == ${aHex}`, () => {
		assert.is(a.eq(b), true);
	});
	tsts(`${aHex} <= ${bHex}`, () => {
		assert.is(a.lte(b), true);
	});
	tsts(`${aHex} >= ${bHex}`, () => {
		assert.is(a.gte(b), true);
	});
}

// prettier-ignore
const lt_set:[string,string][]=[
    [h0,h1],
    [h1,hNum],
    [hNum,hMax],
	['01020304050607080102030405060708','01020304050607080102030405060709'],
    ['01020304050607080102030405060708','01020304050607080102030405060808'],
    ['01020304050607080102030405060708','01020304050607080102030405070708'],
    ['01020304050607080102030405060708','01020304050607080102030406060708'], 
    ['01020304050607080102030405060708','01020304050607080102030505060708'], 
    ['01020304050607080102030405060708','01020304050607080102040405060708'], 
    ['01020304050607080102030405060708','01020304050607080103030405060708'], 
    ['01020304050607080102030405060708','01020304050607080202030405060708'],  
    ['01020304050607080102030405060708','01020304050607090102030405060708'],  
    ['01020304050607080102030405060708','01020304050608080102030405060708'],  
    ['01020304050607080102030405060708','01020304050707080102030405060708'],  
    ['01020304050607080102030405060708','01020304060607080102030405060708'],  
    ['01020304050607080102030405060708','01020305050607080102030405060708'],  
    ['01020304050607080102030405060708','01020404050607080102030405060708'],  
    ['01020304050607080102030405060708','01030304050607080102030405060708'],  
    ['01020304050607080102030405060708','02020304050607080102030405060708'],  
];
for (const [aHex, bHex] of lt_set) {
	const a = hexBuild(aHex);
	const b = hexBuild(bHex);
	tsts(`${aHex} < ${bHex}`, () => {
		assert.is(a.lt(b), true);
	});
	tsts(`${bHex} > ${aHex}`, () => {
		assert.is(b.gt(a), true);
	});
	tsts(`${aHex} <= ${bHex}`, () => {
		assert.is(a.lte(b), true);
	});
	tsts(`${bHex} >= ${aHex}`, () => {
		assert.is(b.gte(a), true);
	});
}
//#endregion

tsts(`clone`, () => {
	//Really just for coverage (since you cannot mutate, what's the value of a clone?)
	const a = U128.fromInt(1);
	const b = a.clone();
	//Object eq tests
	assert.is(a, a);
	assert.is.not(a, b);
});

tsts(`mut`, () => {
	const a = U128.fromInt(1);
	assert.is(hex.fromBytes(a.toBytesBE()), h1);
	const b = a.mut();
	b.addEq(U128.fromInt(1));
	assert.is(hex.fromBytes(a.toBytesBE()), h1, 'a has not changed');
	assert.is(
		hex.fromBytes(b.toBytesBE()),
		'00000000000000000000000000000002',
		'b is updated'
	);
});

tsts(`zero`, () => {
	assert.equal(U128.zero.toBytesBE(), new Uint8Array(16));
});

tsts('[Symbol.toStringTag]', () => {
	const o = U128.fromInt(1);
	const str = Object.prototype.toString.call(o);
	assert.is(str.indexOf('U128') > 0, true);
});

tsts('util.inspect', () => {
	const o = U128.fromInt(1);
	const u = util.inspect(o);
	assert.is(u.startsWith('U128('), true);
});

tsts.run();
