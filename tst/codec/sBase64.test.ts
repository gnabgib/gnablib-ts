import { suite } from 'uvu';
import * as assert from 'uvu/assert';
import { sBase64 } from '../../src/codec';
import {  hex, utf8 } from '../../src/codec';

const tsts = suite('sBase64');
//const b=new SBase64();
// b: ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/
// s: ?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_`abcdefghijklmnopqrstuvwxyz{|}~
const asciiTests = [
    //These were hand generated by using Base64 output and converting using above xref
	['', ''],
	['f', 'X_'],
	['fo', 'Xe{'],
	['foo', 'Xe|n'],
	['foob', 'Xe|nW_'],
	['fooba', 'Xe|nWeC'],
	['foobar', 'Xe|nWeDq'],
	['Hello!', 'QETkZE{`'],
	['Hello, world!', 'QETkZE{kGF\\n[epcGO'],
	['Many hands make light work.', 'RUDm]Q@gWUxc[q@lWUldGEphXu`sGF\\n[ekm'],
	['light w', 'ZEdfYFO_\\o'],
	['light wo', 'ZEdfYFO_\\u{'],
	['light wor', 'ZEdfYFO_\\u|q'],
];

for (const [str, enc] of asciiTests) {
	tsts(`fromBytes(${str})`, () => {        
		const u = utf8.toBytes(str);
		assert.is(sBase64.fromBytes(u), enc);
	});

	tsts(`toBytes(${enc})`, () => {
		const u = sBase64.toBytes(enc);
		assert.is(utf8.fromBytes(u), str);
	});
}

const hexTests:[string,string][]=[
    ['',''],
    ['00','??'],//00 000000
    ['0000','???'],//0000 000000 000000
    ['000000','????'],//000000 000000 000000 000000

    ['000102','??CA'],//000000 000000 000100 000010
    ['030405','?oOD'],//000000 110000 010000 000101
    ['060708','@_[G'],//000001 100000 011100 001000
    ['090A0B','AOgJ'],//000010 010000 101000 001011
    ['0C0D0E','B?sM'],//000011 000000 110100 001110
    ['0F1020','Bp?_'],//000011 110001 000000 100000
    ['304050','KC@O'],//001100 000100 000001 010000
    ['607080','WFA?'],//011000 000111 000010 000000
    ['90A0B0','cIAo'],//100100 001010 000010 110000
    ['C0D0E0','oLB_'],//110000 001101 000011 100000
    ['F0F8FF','{Nb~'],//111100 001111 100011 111111
    
    //All 64 output digits
    ['001083','?@AB'],//000000 000001 000010 000011 0 - 3
    ['105187','CDEF'],//000100 000101 000110 000111 4 - 7
    ['20928B','GHIJ'],//001000 001001 001010 001011 8 -11
    ['30D38F','KLMN'],//001100 001101 001110 001111 12-15

    ['411493','OPQR'],//010000 010001 010010 010011 16-19
    ['515597','STUV'],//010100 010101 010110 010111 20-23
    ['61969B','WXYZ'],//011000 011001 011010 011011 24-27
    ['71D79F','[\\]^'],//011100 011101 011110 011111 28-31

    ['8218A3','_`ab'],//100000 100001 100010 100011 0 - 3
    ['9259A7','cdef'],//100100 100101 100110 100111 4 - 7
    ['A29AAB','ghij'],//101000 101001 101010 101011 8 -11
    ['B2DBAF','klmn'],//101100 101101 101110 101111 12-15

    ['C31CB3','opqr'],//110000 110001 110010 110011 16-19
    ['D35DB7','stuv'],//110100 110101 110110 110111 20-23
    ['E39EBB','wxyz'],//111000 111001 111010 111011 24-27
    ['F3DFBF','{|}~'],//111100 111101 111110 111111 28-31

    ['C7','po'],
    ['8C3B','bBk'],
    ['DEADBEEF','viu}zo'],
];
for (const [strHex, enc] of hexTests) {
	tsts(`fromBytes(x${strHex})`, () => {
		const bytes = hex.toBytes(strHex);
		assert.is(sBase64.fromBytes(bytes), enc);
	});

	tsts(`toBytes(${enc})`, () => {
		const u = sBase64.toBytes(enc);
		assert.is(hex.fromBytes(u), strHex);
	});

    tsts(`toBytesFast(${enc})`, () => {
		const u = sBase64.toBytesFast(enc);
		assert.is(hex.fromBytes(u), strHex);
	});
}

//Not enough characters
tsts(`toBytes(?) throws`,()=>{
    assert.throws(()=>sBase64.toBytes('?'));
});
tsts(`toBytesFast(?) throws`,()=>{
    assert.throws(()=>sBase64.toBytesFast('?'));
});

const badBase:[string,string][]=[
    //Invalid characters

    //'01'=48,49 -63=-15,-14 &b111111= 110001, 110010 =11000111 0010 (note carry)
    ['01','C7'],

    //€= 0xE282AC in utf8, so it doesn't decode into 2, so result is 0000
    //https://symbl.cc/en/20AC/
    // -63-=C1C1 &63=000001 000001 = 00000100 0001 (carry)
    ['€1','04'],

    //€= 0xE282AC in utf8, 2nd 3rd chars don't get written = E282AC
    // -63=A3426D =100011 000011 101101 = 10001100 00111011 01 (carry) = 8C3B
    ['€10','8C3B'],
    ['€aa','8C3B'],//Since char 2,3 ignored the result is the same
];
for(const [sbase,fastDecodeHex] of badBase) {
    tsts(`toBytes(${sbase}) throws`,()=>{
        assert.throws(()=>sBase64.toBytes(sbase));
    });

    tsts(`toBytesFast(${sbase}) wonks`,()=>{
        const u=sBase64.toBytesFast(sbase);
        assert.is(hex.fromBytes(u),fastDecodeHex);
    });
}

tsts.run();
